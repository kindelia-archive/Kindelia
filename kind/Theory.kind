typeof<A: Type>(a: A): Type
  A

type Quartet<
  A: Type
  B: Type
  C: Type
  D: Type
> {
  new(
    fst: A
    snd: B
    trd: C
    frt: D
  )
}

type Quintet<
  A: Type
  B: Type
  C: Type
  D: Type
  E: Type
> {
  new(
    fst: A
    snd: B
    trd: C
    frt: D
    fft: E
  )
}

// TODO
String.eql.equal(
  r: String
  s: String
  Hyp: Equal<Bool>(String.eql(r, s), true)
): Equal<String>(r, s)
  ?string.eql.equal

Theory.Type.equal(
  a: Kindelia.Type
  b: Kindelia.Type
  Hyp: Equal<Bool>(Kindelia.equal(a, b), true)
): Equal<Kindelia.Type>(a, b)
  case a b with Hyp {
    word word:
      refl
    data data:
      let lemma = String.eql.equal!!(Hyp)
      let qed = apply(Kindelia.Type.data, lemma)
      qed
    effe effe:
      let ind = Theory.Type.equal!!(Hyp)
      let qed = apply(Kindelia.Type.effe, ind)
      qed
  }! default
    let contra = Bool.false_neq_true(Hyp)
    Empty.absurd!(contra)

type KeyValue <K: Type, V: Type, M: Type> {
  new(
    empty: M
    get: K -> M -> Maybe(V)
    set: K -> V -> M -> M
    del: K -> M -> M
    set_value: (k: K, v: V, m: M) -> Equal<Maybe<V>>(get(k, set(k, v, m)), Maybe.some<V>(v))
    set_preserve: (k0: K, k1: K, v: V, m: M, Hyp: Not(Equal<K>(k0, k1))) -> Equal<Maybe(V)>(get(k0, set(k1, v, m)), get(k0, m))
    del_value: (k: K, m: M) -> Equal<Maybe<V>>(get(k, del(k, m)), Maybe.none<V>)
    get_empty: (k: K) -> Equal<Maybe(V)>(get(k, empty), Maybe.none<V>)
  )
}

// TODO
Map.KeyValue<T: Type>: KeyValue<String, T, Map<T>>
  KeyValue.new<String, T, Map<T>>(
    Map.new<T>
    Map.get<T>
    Map.set<T>
    Map.delete<T>
    ?map.set_value
    ?map.set_preserve
    ?map.del_value
    ?map.get_empty
  )

Kindelia.Data.KeyValue: KeyValue<String, Kindelia.Constructor, Kindelia.Data>
  ?keyvalue

Kindelia.Entry.IsSomeFile(e: Maybe<Kindelia.Entry>): Type
  case e {
    some:
      case e.value {
        file:
          Unit
      } default Empty
  } default Empty

// TODO maybe pass a type to the inside?
Kindelia.Type.IsEffect(t: Kindelia.Type): Type
  case t {
    effe:
      Unit
  } default Empty

Theory.WellTyped(
  world: Map<Kindelia.Entry>
  context: Map<Kindelia.Type>
  term: Kindelia.Term
  type: Kindelia.Type
): Type
  case term {
    // if (name : type) is in context
    // ------------------------------
    // context |- name : type
    var:
      Equal<Maybe<Kindelia.Type>>(
        Map.get<Kindelia.Type>(term.name, context)
        Maybe.some<Kindelia.Type>(type)
      )

    // context             |- expr : A
    // context, (name : A) |- body : B
    // --------------------------------------
    // context |- (let name = expr; body) : B
    let:
      And<
        Theory.WellTyped(world, context, term.expr, term.type)
        Theory.WellTyped(
          world
          Map.set<Kindelia.Type>(term.name, term.type, context)
          term.body
          type
        )
      >

    call:
      case Map.get<Kindelia.Entry>(term.bond, world) as b {
        some:
          case b.value as b {
            bond:
              case b.value as b {
                new:
                  // TODO how express that the bond is well-typed?
                  And<
                    Theory.WellTyped.param_list(
                      world
                      context
                      b.iprm
                      term.args
                    )
                    Equal<Kindelia.Type>(
                      type
                      b.otyp
                    )
                  >
              }
          } default Empty
      } default Empty

    create:
      case type {
        data:
          case Map.get<Kindelia.Entry>(type.name, world) as t {
            some:
              case t.value as t {
                data:
                  case Kindelia.get_constructor_value(t.value, term.ctor) as ctor {
                    some:
                      case ctor.value as ctor {
                        new:
                          Theory.WellTyped.param_list(
                            world
                            context
                            ctor.fprm
                            term.vals
                          )
                      }
                  } default Empty
              } default Empty
          } default Empty
      } default Empty

    match:
      case Kindelia.get_data(world, term.data) as data {
        some:
          case data.value {
            new:
              Theory.WellTyped.match(
                world
                context
                term.name
                term.cses
                data.value.constructors
                type
              )
          }
      } default Empty

    // ~
    // ---------------------
    // context |- #n : #word
    word:
      Equal<Kindelia.Type>(type, Kindelia.Type.word)

    // context |- n : #word
    // context |- m : #word
    // context |- l : A
    // context |- e : A
    // context |- g : A
    // -----------------------------------------------------------
    // context |- (compare n m { _<_: l, _=_: e, _>_: g }) : #word
    compare:
      Quintet<
        Theory.WellTyped(world, context, term.val0, Kindelia.Type.word)
        Theory.WellTyped(world, context, term.val1, Kindelia.Type.word)
        Theory.WellTyped(world, context, term.iflt, type)
        Theory.WellTyped(world, context, term.ifeq, type)
        Theory.WellTyped(world, context, term.ifgt, type)
      >

    // if X is one of: + - * / % | & ^
    // context |- n : #word
    // context |- m : #word
    // -------------------------------
    // context |- X(n, m) : #word
    operate:
      Triple<
        Equal<Kindelia.Type>(type, Kindelia.Type.word)
        Theory.WellTyped(world, context, term.val0, Kindelia.Type.word)
        Theory.WellTyped(world, context, term.val1, Kindelia.Type.word)
      >

    // given file a : A
    //
    // context |- k : A
    // context |- r : &B
    // ------------------------------
    // context |- (set a = k; r) : &B
    set:
      Triple<
        Kindelia.Type.IsEffect(type)
        Theory.WellTyped(world, context, term.body, type)
        case Map.get<Kindelia.Entry>(term.file, world) as f {
          some:
            case f.value as f {
              file:
                case f.value as f {
                  new:
                      Theory.WellTyped(world, context, term.expr, f.type)
                }
            } default Empty
        } default Empty
      >

    // given file a : A
    //
    // context, (x : A) |- r : &B
    // ------------------------------
    // context |- (get x = a; r) : &B
    get:
      And<
        Kindelia.Type.IsEffect(type)
        case Map.get<Kindelia.Entry>(term.file, world) as f {
          some:
            case f.value as f {
              file:
                case f.value as f {
                  new:
                    // TODO include ownership too?
                    Theory.WellTyped(
                      world
                      Map.set<Kindelia.Type>(
                        term.name
                        f.type
                        context
                      )
                      term.body
                      type
                    )
                }
            } default Empty
        } default Empty
      >

    // context          |- e : &A
    // context, (x : A) |- c : &B
    // ----------------------------------
    // context |- (run x : A = e; c) : &B
    bind:
      Triple<
        Theory.WellTyped(
          world
          context
          term.expr
          term.type
        )
        case term.type {
          effe:
            Theory.WellTyped(
              world
              Map.set<Kindelia.Type>(
                term.name
                term.type.rety
                context
              )
              term.body
              type
            )
        } default Empty
        Kindelia.Type.IsEffect(type)
      >

    return:
      case type {
        effe:
          Theory.WellTyped(
            world
            context
            term.expr
            type.rety
          )
      } default Empty
  }

Theory.WellTyped.param_list(
  world: Map<Kindelia.Entry>
  context: Map<Kindelia.Type>
  binders: List<Pair<String, Kindelia.Type>>
  args: List<Kindelia.Term>
): Type
  case binders args {
    cons cons:
      case binders.head {
        new:
          And<
           Theory.WellTyped(
             world
             context
             args.head
             binders.head.snd
           )
           Theory.WellTyped.param_list(
             world
             context
             binders.tail
             args.tail
           )
          >
      }
    nil nil:
      Unit
  } default Empty

Theory.WellTyped.match(
  world: Kindelia.World
  context: Map<Kindelia.Type>
  name: String
  cses: List<Kindelia.Term>
  ctrs: List<Kindelia.Constructor>
  type: Kindelia.Type
): Type
  case ctrs cses {
    nil nil:
      Unit
    cons cons:
      case ctrs.head as ctrs{
        new:
          let nams = List.map!!((fprm) name|"."|fprm@fst, ctrs.fprm)
          let typs = List.mapped!(ctrs.fprm)!(Pair.snd!!)
          And<
            Theory.WellTyped(
              world
              Kindelia.extend<Kindelia.Type>(
                context
                nams
                typs
              )
              cses.head
              type
            )
            Theory.WellTyped.match(
              world
              context
              name
              cses.tail
              ctrs.tail
              type
            )
          >
      }
  } default Empty

// That's false
//
//Theory.WellTyped.deterministic(
//  world: Map<Kindelia.Entry>
//  context: Map<Kindelia.Type>
//  term: Kindelia.Term
//  type0: Kindelia.Type
//  type1: Kindelia.Type
//  Hyp0: Theory.WellTyped(world, context, term, type0)
//  Hyp1: Theory.WellTyped(world, context, term, type1)
//): Equal<Kindelia.Type>(type0, type1)
//  case term with Hyp0 Hyp1 {
//    var:
//      let lemma = Equal.right<Maybe<Kindelia.Type>>(
//        Map.get<Kindelia.Type>(term.name, context)
//        Maybe.some<Kindelia.Type>(type0), Maybe.some<Kindelia.Type>(type1)
//        Hyp0, Hyp1
//      )
//      let qed = Maybe.some_inj!!!(lemma)
//      qed
//    let:
//      case Hyp0 Hyp1 {
//        new new:
//          let qed = Theory.WellTyped.deterministic(
//            world, Map.set(Kindelia.Type,term.name,term.type,context)
//            term.body, type0, type1
//            Hyp0.snd, Hyp1.snd
//          )
//          qed
//      }
//    call:
//      ?call
//    create:
//      ?create
//    match:
//      ?match
//    word:
//      Equal.left<Kindelia.Type>(Kindelia.Type.word, type0, type1, Hyp0, Hyp1)
//    compare:
//      case Hyp0 Hyp1 {
//        new new:
//          Theory.WellTyped.deterministic(world, context, term.iflt, type0, type1, Hyp0.trd, Hyp1.trd)
//      }
//    operate:
//      case Hyp0 Hyp1 {
//        new new:
//          Equal.left<Kindelia.Type>(Kindelia.Type.word, type0, type1, Hyp0.fst, Hyp1.fst)
//      }
//    set:
//      case Hyp0 Hyp1 {
//        new new:
//          Theory.WellTyped.deterministic(world, context, term.body, type0, type1, Hyp0.snd, Hyp1.snd)
//      }
//    get:
//      case Hyp0 Hyp1 {
//        new new:
//          case Map.get(Kindelia.Entry, term.file, world) as f with Hyp0.snd Hyp1.snd {
//            some:
//              case f.value as f with Hyp0.snd Hyp1.snd {
//                file:
//                  case f.value as f with Hyp0.snd Hyp1.snd {
//                    new:
//                      Theory.WellTyped.deterministic(
//                        world
//                        Map.set<Kindelia.Type>(
//                          term.name
//                          f.type
//                          context
//                        )
//                        term.body
//                        type0
//                        type1
//                        Hyp0.snd
//                        Hyp1.snd
//                      )
//                  }!
//              }! default Empty.absurd!(Hyp0.snd)
//          }! default Empty.absurd!(Hyp0.snd)
//      }
//    bind:
//      case Hyp0 Hyp1 {
//        new new:
//          case term.type with Hyp0.snd Hyp1.snd {
//            effe:
//              Theory.WellTyped.deterministic(
//                world
//                Map.set(Kindelia.Type,term.name,term.type.rety,context)
//                term.body, type0, type1
//                Hyp0.snd, Hyp1.snd
//              )
//          }! default Empty.absurd!(Hyp0.snd)
//      }
//    return:
//      case type0 with Hyp0 {
//        effe:
//          case type1 with Hyp1 {
//            effe:
//              let ind =
//                Theory.WellTyped.deterministic(
//                  world
//                  context
//                  term.expr
//                  type0.rety
//                  type1.rety
//                  Hyp0
//                  Hyp1
//                )
//              let qed = apply(Kindelia.Type.effe, ind)
//              qed
//          }! default Empty.absurd!(Hyp1)
//      }! default Empty.absurd!(Hyp0)
//  }!
