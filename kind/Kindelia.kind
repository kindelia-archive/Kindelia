// Kindelia: a minimal decentralized computer
// ==========================================

// Types
// -----

// A Kindelia term
type Kindelia.Term {
  // A variable
  var(
    name: String
  )
  // Call external function
  call(
    bond: String
    args: List<Kindelia.Term>
  )
  // Assigns a variable
  let(
    name: String
    type: Kindelia.Type
    expr: Kindelia.Term
    body: Kindelia.Term
  )
  // Creates a value
  create(
    ctor: String
    vals: List<Kindelia.Term>
  )
  // Pattern-matches a value
  match(
    name: String
    data: String
    cses: List<Kindelia.Term>
  )
  // Creates a new 64-bit word
  word(
    numb: U64
  )
  // Compares two words
  compare(
    val0: Kindelia.Term
    val1: Kindelia.Term
    iflt: Kindelia.Term
    ifeq: Kindelia.Term
    ifgt: Kindelia.Term
  )
  // Binary operation on words
  operate(
    oper: Kindelia.Operation
    val0: Kindelia.Term
    val1: Kindelia.Term
  )
  // Effect: sets a file
  set(
    file: String
    expr: Kindelia.Term
    body: Kindelia.Term
  )
  // Effect: gets a file
  get(
    name: String
    file: String
    body: Kindelia.Term
  )
  // Effect: chains two effects
  bind(
    name: String
    type: Kindelia.Type
    expr: Kindelia.Term
    body: Kindelia.Term
  )
  // Effect: wraps a pure value
  return(
    expr: Kindelia.Term
  )
}

// A binary operation on words
type Kindelia.Operation {
  add sub mul div mod or and xor
}

// A type reference
type Kindelia.Type {
  word
  data(name: String)
  effe(rety: Kindelia.Type)
}

// A global algebraic datatype (ADT) declaration
type Kindelia.Data {
  new(
    name: String
    constructors: List<Kindelia.Constructor>
  )
}

// An ADT's constructor
type Kindelia.Constructor {
  new(
    name: String
    fprm: List<Pair<String, Kindelia.Type>>
  )
}

// A global function
type Kindelia.Bond {
  new(
    name: String
    iprm: List<Pair<String, Kindelia.Type>>
    otyp: Kindelia.Type
    main: Kindelia.Term
  )
}

// A global state
type Kindelia.File {
  new(
    name: String
    ownr: List<String>
    type: Kindelia.Type
    expr: Kindelia.Term
  )
}

// An evaluation
type Kindelia.Eval {
  new(
    term: Kindelia.Term
    type: Kindelia.Type
  )
}

// A global entry
type Kindelia.Entry {
  data(value: Kindelia.Data)
  bond(value: Kindelia.Bond)
  file(value: Kindelia.File)
}

// A Kindelia transaction
type Kindelia.Transaction {
  new_data(data: Kindelia.Data)
  new_bond(bond: Kindelia.Bond)
  new_file(file: Kindelia.File)
  new_eval(eval: Kindelia.Eval)
}

Kindelia.World: Type
  Map<Kindelia.Entry>

type Kindelia.Runtime <A: Type> {
  new(
    world: Kindelia.World
    subst: Map<Kindelia.Term>
    fresh: Nat
    gas: Nat
    term: A
  )
}

Kindelia.Runtime.Term: Type
  Kindelia.Runtime<Kindelia.Term>

Kindelia.Runtime.Terms: Type
  Kindelia.Runtime<List<Kindelia.Term>>

// Utils
// -----

Kindelia.genesis: Kindelia.World
  {}

Kindelia.get_data(world: Kindelia.World, name: String): Maybe<Kindelia.Data>
  Maybe {
    get entry = world{name}
    case entry {
      data: some(entry.value)
    } default none
  }

Kindelia.get_bond(world: Kindelia.World, name: String): Maybe<Kindelia.Bond>
  Maybe {
    get entry = world{name}
    case entry {
      bond: some(entry.value)
    } default none
  }

Kindelia.get_file(world: Kindelia.World, name: String): Maybe<Kindelia.File>
  Maybe {
    get entry = world{name}
    case entry {
      file: some(entry.value)
    } default none
  }

Kindelia.get_constructors(world: Kindelia.World, name: String): Maybe<List<Kindelia.Constructor>>
  case Kindelia.get_data(world, name) as got {
    none: none
    some: some(got.value@constructors)
  }

Kindelia.get_constructor_index(data: Kindelia.Data, name: String): Maybe<Nat>
  Maybe.mapped!(List.ifind!((i,ctr) String.eql(ctr@name,name), data@constructors))!((x) x@fst)

Kindelia.get_constructor_value(data: Kindelia.Data, name: String): Maybe<Kindelia.Constructor>
  Maybe.mapped!(List.ifind!((i,ctr) String.eql(ctr@name,name), data@constructors))!((x) x@snd)

Kindelia.extend<A: Type>(
  map: Map<A>
  keys: List<String>
  vals: List<A>
): Map<A>
  case keys vals {
    cons cons: Kindelia.extend<A>(Map.set!(keys.head, vals.head, map), keys.tail, vals.tail)
  } default map

// Type-Checking
// -------------

Kindelia.equal(a: Kindelia.Type, b: Kindelia.Type): Bool
  case a b {
    word word: true
    data data: String.eql(a.name, b.name)
    effe effe: Kindelia.equal(a.rety, b.rety)
  } default false

Kindelia.check(
  context: Map<Kindelia.Type>
  world: Kindelia.World
  term: Kindelia.Term
  type: Kindelia.Type
  caller: Maybe<String>
): Bool
  open context
  //log("-- chk " | Kindelia.show.term(world,term) | " : " | Kindelia.show.type(world,type))
  //log("-- ctx: " | String.join(", ", List.map!!((a) a@fst|":"|Kindelia.show.type(world,a@snd), Map.to_list!(context))))  // DEBUG
  //log("")  // DEBUG
  case term {
    var:
      let var_type = context{term.name} abort false
      ////log("-- var " | term.name | " " | Kindelia.show.type(var_type) | " " | Kindelia.show.type(world,type))  // DEBUG
      Kindelia.equal(var_type, type)
    let:
      //log("-- let ")  // DEBUG
      let expr = Kindelia.check(context, world, term.expr, term.type, caller)
      let ctx2 = Map.set!(term.name, term.type, context)
      let body = Kindelia.check(ctx2, world, term.body, type, caller)
      expr && body
    call:
      //log("-- call ")  // DEBUG
      //let ownr = Kindelia.World.check.owner(context, term.func)
      
      use bond = Kindelia.get_bond(world, term.bond) abort false
      let otyp = Kindelia.equal(bond.otyp, type)
      let ityp = List.mapped!(bond.iprm)!(Pair.snd!!)
      let args = List.zip!!(term.args, ityp)
      let args = List.all!((x) Kindelia.check(context, world, x@fst, x@snd, caller), args)
      otyp && args
    create: case type {
      data:
        use data = Kindelia.get_data(world, type.name) abort false
        use ctor = Kindelia.get_constructor_value(data,term.ctor) abort false
        let size = Nat.eql(List.length!(term.vals), List.length!(ctor.fprm))
        let ftyp = List.mapped!(ctor.fprm)!(Pair.snd!!)
        let vals = List.zip!!(term.vals, ftyp)
        let vals = List.all!((x) Kindelia.check(context, world, x@fst, x@snd, caller), vals)
        size && vals
    } default false
    match: 
      use data = Kindelia.get_data(world, term.data) abort false
      let size = Nat.eql(List.length!(term.cses),List.length!(data.constructors))
      let expr = Kindelia.check(context, world, Kindelia.Term.var(term.name), Kindelia.Type.data(term.data), caller)
      let cses = List.zipped_with!!(term.cses, data.constructors)!((case_body, case_ctor)
        let nams = List.map!!((fprm) term.name|"."|fprm@fst, case_ctor@fprm)
        let typs = List.mapped!(case_ctor@fprm)!(Pair.snd!!)
        let ctx2 = Kindelia.extend!(context, nams, typs)
        Kindelia.check(ctx2, world, case_body, type, caller))
      size && List.and(cses)
    word: case type {
      word: true
    } default false
    compare:
      //log("-- compare ")  // DEBUG
      let val0 = Kindelia.check(context, world, term.val0, Kindelia.Type.word, caller)
      let val1 = Kindelia.check(context, world, term.val1, Kindelia.Type.word, caller)
      let iflt = Kindelia.check(context, world, term.iflt, type, caller)
      let ifeq = Kindelia.check(context, world, term.ifeq, type, caller)
      let ifgt = Kindelia.check(context, world, term.ifgt, type, caller)
      val0 && val1 && iflt && ifeq && ifgt
    operate:
      let val0 = Kindelia.check(context, world, term.val0, Kindelia.Type.word, caller)
      let val1 = Kindelia.check(context, world, term.val1, Kindelia.Type.word, caller)
      val0 && val1
    set: case type {
      effe: 
        use file = Kindelia.get_file(world, term.file) abort false
        let empty = List.is_empty!(file.ownr)
        let valid = Maybe.if!((x) List.in!(String.eql(x), file.ownr), caller)
        let ownr = empty || valid
        let expr = Kindelia.check(context, world, term.expr, file.type, caller)
        let body = Kindelia.check(context, world, term.body, type, caller)
        ownr && expr && body
    } default false
    get: case type {
      effe: 
        use file = Kindelia.get_file(world, term.file) abort false
        let ctx2 = Kindelia.extend!(context, [term.name], [file.type])
        let body = Kindelia.check(ctx2, world, term.body, type, caller)
        body
    } default false
    bind: case type {
      effe:
        let expr = Kindelia.check(context, world, term.expr, Kindelia.Type.effe(term.type), caller)
        let ctx2 = Map.set!(term.name, term.type, context)
        let body = Kindelia.check(ctx2, world, term.body, type, caller)
        expr && body
    } default false
    return: case type {
      effe: Kindelia.check(context, world, term.expr, type.rety, caller)
    } default false
  } default false

// Evaluation
// ----------

// Reduces a pure term to weak normal form
Kindelia.reduce(state: Kindelia.Runtime.Term): Kindelia.Runtime.Term
  let {world, subst, fresh, gas, term} = state
  //log("-- run " | Kindelia.show.term(world,term)) // DEBUG
  //log("-- var " | String.join(", ", List.map!!((x) x@fst|":"|Kindelia.show.term(world,x@snd), Map.to_list!(subst)))) // DEBUG
  //log("")
  case term {
    var:
      let term = subst{term.name} <> term
      let {world, subst, fresh, gas, term} = Kindelia.reduce({world, subst, fresh, gas, term})
      {world, Map.set!(term.name, term, subst), fresh, gas, term}
    let:
      Kindelia.reduce({world, Map.set!(term.name, term.expr, subst), fresh, gas, term.body})
    call:
      use bond = Kindelia.get_bond(world, term.bond) abort state
      let inam = List.mapped!(bond.iprm)!(Pair.fst!!)
      let {table, fresh, inam} = Kindelia.rename.many({}, fresh, inam)
      let {fresh, main} = Kindelia.sanitize(world, table, fresh, bond.main)
      let subst = Kindelia.extend!(subst, inam, term.args)
      //log("calling " | bond.name | ": " | Kindelia.show.term(world,main) | " ... " | String.join(",",bond.inam) | " ... " | String.join(",",inam))
      Kindelia.reduce({world, subst, fresh, gas, main})
    match:
      let {world, subst, fresh, gas, expr} = Kindelia.reduce({world, subst, fresh, gas, subst{term.name}<>Kindelia.Term.word(0)})
      case expr {
        create:
          use data = Kindelia.get_data(world,term.data) abort state
          use ctor = Kindelia.get_constructor_value(data,expr.ctor) abort state
          let indx = Kindelia.get_constructor_index(data,expr.ctor) abort state
          let body = term.cses[indx] abort state
          let nams = List.map!!((fprm) term.name|"."|fprm@fst, ctor@fprm)
          let subst = Kindelia.extend!(subst, nams, expr.vals)
          Kindelia.reduce({world, subst, fresh, gas, body})
      } default state
    compare:
      let {world, subst, fresh, gas, val0} = Kindelia.reduce({world, subst, fresh, gas, term.val0})
      let {world, subst, fresh, gas, val1} = Kindelia.reduce({world, subst, fresh, gas, term.val1})
      case val0 val1 {
        word word: case U64.cmp(val0.numb, val1.numb) {
          ltn: Kindelia.reduce({world, subst, fresh, gas, term.iflt})
          eql: Kindelia.reduce({world, subst, fresh, gas, term.ifeq})
          gtn: Kindelia.reduce({world, subst, fresh, gas, term.ifgt})
        }
      } default state
    operate:
      let {world, subst, fresh, gas, val0} = Kindelia.reduce({world, subst, fresh, gas, term.val0})
      let {world, subst, fresh, gas, val1} = Kindelia.reduce({world, subst, fresh, gas, term.val1})
      case val0 val1 {
        word word: case term.oper {
          add: {world, subst, fresh, gas, Kindelia.Term.word(U64.add(val0.numb,val1.numb))}
          sub: {world, subst, fresh, gas, Kindelia.Term.word(U64.sub(val0.numb,val1.numb))}
          mul: {world, subst, fresh, gas, Kindelia.Term.word(U64.mul(val0.numb,val1.numb))}
          div: {world, subst, fresh, gas, Kindelia.Term.word(U64.div(val0.numb,val1.numb))}
          mod: {world, subst, fresh, gas, Kindelia.Term.word(U64.mod(val0.numb,val1.numb))}
          or:  {world, subst, fresh, gas, Kindelia.Term.word(U64.or( val0.numb,val1.numb))}
          and: {world, subst, fresh, gas, Kindelia.Term.word(U64.and(val0.numb,val1.numb))}
          xor: {world, subst, fresh, gas, Kindelia.Term.word(U64.xor(val0.numb,val1.numb))}
        }
      } default state
  } default state

// Runs an effect
Kindelia.run(state: Kindelia.Runtime.Term): Kindelia.Runtime.Term
  let {world, subst, fresh, gas, term} = Kindelia.reduce(state)
  case term {
    set:
      use file = Kindelia.get_file(world, term.file) abort state
      let {world, subst, fresh, gas, expr} = Kindelia.normalize({world, subst, fresh, gas, term.expr})
      let new_entry = Kindelia.Entry.file(file@expr <- expr)
      let new_world = Map.set!(term.file, new_entry, world)
      //log("-- rebind " | term.name)
      //log("--- from: " | Kindelia.show.term(world, bond.main))
      //log("--- to..: " | Kindelia.show.term(world, main))
      Kindelia.run({new_world, subst, fresh, gas, term.body})
    get:
      use file = Kindelia.get_file(world, term.file) abort state
      Kindelia.run({world, Map.set!(term.name, file.expr, subst), fresh, gas, term.body})
    bind:
      let {world, subst, fresh, gas, expr} = Kindelia.run({world, subst, fresh, gas, term.expr})
      case expr {
        return: Kindelia.run({world, Map.set!(term.name, expr.expr, subst), fresh, gas, term.body})
      } default {world, subst, fresh, gas, Kindelia.Term.bind(term.name, term.type, expr, term.body)}
  } default {world, subst, fresh, gas, term}

// Reduces a term to normal form
Kindelia.normalize(state: Kindelia.Runtime.Term): Kindelia.Runtime.Term
  let {world, subst, fresh, gas, term} = Kindelia.reduce(state)
  //log("- nrm " | Kindelia.show.term(world,term)) // DEBUG
  //log("- var " | String.join(", ", List.map!!((x) x@fst|":"|Kindelia.show.term(world,x@snd), Map.to_list!(subst)))) // DEBUG
  //log("")
  case term {
    create:
      let {world, subst, fresh, gas, vals} = Kindelia.normalize.many({world, subst, fresh, gas, term.vals})
      {world, subst, fresh, gas, Kindelia.Term.create(term.ctor, vals)}
    match:
      use ctrs = Kindelia.get_constructors(world, term.data) abort {world, subst, fresh, gas, term}
      let {world, subst, fresh, gas, cses} = Kindelia.normalize.cases(ctrs, term.name, {world, subst, fresh, gas, term.cses})
      {world, subst, fresh, gas, Kindelia.Term.match(term.name, term.data, cses)}
    compare:
      let {world, subst, fresh, gas, val0} = Kindelia.normalize({world, subst, fresh, gas, term.val0})
      let {world, subst, fresh, gas, val1} = Kindelia.normalize({world, subst, fresh, gas, term.val1})
      let {world, subst, fresh, gas, iflt} = Kindelia.normalize({world, subst, fresh, gas, term.iflt})
      let {world, subst, fresh, gas, ifeq} = Kindelia.normalize({world, subst, fresh, gas, term.ifeq})
      let {world, subst, fresh, gas, ifgt} = Kindelia.normalize({world, subst, fresh, gas, term.ifgt})
      {world, subst, fresh, gas, Kindelia.Term.compare(val0, val1, iflt, ifeq, ifgt)}
    operate:
      let {world, subst, fresh, gas, val0} = Kindelia.normalize({world, subst, fresh, gas, term.val0})
      let {world, subst, fresh, gas, val1} = Kindelia.normalize({world, subst, fresh, gas, term.val1})
      {world, subst, fresh, gas, Kindelia.Term.operate(term.oper, val0, val1)}
    set:
      use file = Kindelia.get_file(world, term.file) abort state
      let {world, subst, fresh, gas, expr} = Kindelia.normalize({world, subst, fresh, gas, term.expr})
      let {world, subst, fresh, gas, body} = Kindelia.normalize({world, subst, fresh, gas, term.body})
      {world, subst, fresh, gas, Kindelia.Term.set(term.file, expr, body)}
    get:
      use file = Kindelia.get_file(world, term.file) abort state
      let {world, subst, fresh, gas, body} = Kindelia.normalize({world, Map.set!(term.name, Kindelia.Term.var(term.name), subst), fresh, gas, term.body})
      {world, subst, fresh, gas, Kindelia.Term.get(term.name, term.file, body)}
    bind:
      let {world, subst, fresh, gas, expr} = Kindelia.normalize({world, subst, fresh, gas, term.expr})
      let {world, subst, fresh, gas, body} = Kindelia.normalize({world, Map.set!(term.name,Kindelia.Term.var(term.name), subst), fresh, gas, term.body})
      {world, subst, fresh, gas, Kindelia.Term.bind(term.name, term.type, expr, body)}
    return:
      let {world, subst, fresh, gas, expr} = Kindelia.normalize({world, subst, fresh, gas, term.expr})
      {world, subst, fresh, gas, Kindelia.Term.return(expr)}
  } default {world, subst, fresh, gas, term}

Kindelia.normalize.bound(names: List<String>, state: Kindelia.Runtime.Term): Kindelia.Runtime.Term
  let {world, subst, fresh, gas, term} = state
  let subst = Kindelia.extend!(subst, names, List.map!!(Kindelia.Term.var,names))
  Kindelia.normalize({world, subst, fresh, gas, term})

Kindelia.normalize.cases(ctrs: List<Kindelia.Constructor>, name: String, state: Kindelia.Runtime.Terms): Kindelia.Runtime.Terms
  let {world, subst, fresh, gas, cses} = state
  case ctrs cses {
    nil nil:
      state
    cons cons:
      let nams = List.map!!((fprm) name|"."|fprm@fst, ctrs.head@fprm)
      let vals = List.map!!(Kindelia.Term.var, nams)
      let subst = Kindelia.extend!(subst, nams, vals)
      let {world, subst, fresh, gas, head} = Kindelia.normalize({world, subst, fresh, gas, cses.head})
      let {world, subst, fresh, gas, tail} = Kindelia.normalize.cases(ctrs.tail, name, {world, subst, fresh, gas, cses.tail})
      {world, subst, fresh, gas, head & tail}
  } default state

Kindelia.normalize.many(state: Kindelia.Runtime.Terms): Kindelia.Runtime.Terms
  let {world, subst, fresh, gas, vals} = state
  case vals {
    nil:
      state
    cons:
      let {world, subst, fresh, gas, head} = Kindelia.normalize({world, subst, fresh, gas, vals.head})
      let {world, subst, fresh, gas, tail} = Kindelia.normalize.many({world, subst, fresh, gas, vals.tail})
      {world, subst, fresh, gas, head & tail}
  }

// Renames variables to unique names
Kindelia.sanitize(
  world: Kindelia.World
  table: Map<String>
  fresh: Nat
  term: Kindelia.Term
): Pair<Nat, Kindelia.Term>
  case term {
    var:
      let term = Kindelia.Term.var(table{term.name} <> term.name)
      //log("rename " | term.name | " to " | (table{term.name} <> term.name))
      {fresh, term}
    call:
      let {fresh, args} = Kindelia.sanitize.many(world, table, fresh, term.args)
      {fresh, Kindelia.Term.call(term.bond, args)}
    let:
      let {fresh, expr} = Kindelia.sanitize(world, table, fresh, term.expr)
      let {table, fresh, name} = Kindelia.rename(table, fresh, term.name)
      let {fresh, body} = Kindelia.sanitize(world, table, fresh, term.body)
      {fresh, Kindelia.Term.let(name, term.type, expr, body)}
    create:
      let {fresh, vals} = Kindelia.sanitize.many(world, table, fresh, term.vals)
      {fresh, Kindelia.Term.create(term.ctor, vals)}
    match:
      let ctrs = Kindelia.get_constructors(world, term.data) <> []
      let old_name = term.name
      let new_name = table{term.name} <> term.name
      let {fresh, cses} = Kindelia.sanitize.cases(world, table, fresh, old_name, new_name, ctrs, term.cses)
      {fresh, Kindelia.Term.match(new_name, term.data, cses)}
    word:
      {fresh, Kindelia.Term.word(term.numb)}
    compare:
      let {fresh, val0} = Kindelia.sanitize(world, table, fresh, term.val0)
      let {fresh, val1} = Kindelia.sanitize(world, table, fresh, term.val1)
      let {fresh, iflt} = Kindelia.sanitize(world, table, fresh, term.iflt)
      let {fresh, ifeq} = Kindelia.sanitize(world, table, fresh, term.ifeq)
      let {fresh, ifgt} = Kindelia.sanitize(world, table, fresh, term.ifgt)
      {fresh, Kindelia.Term.compare(val0, val1, iflt, ifeq, ifgt)}
    operate:
      let {fresh, val0} = Kindelia.sanitize(world, table, fresh, term.val0)
      let {fresh, val1} = Kindelia.sanitize(world, table, fresh, term.val1)
      {fresh, Kindelia.Term.operate(term.oper, val0, val1)}
    set:
      use file = Kindelia.get_file(world, term.file) abort {fresh, term}
      let {fresh, expr} = Kindelia.sanitize(world, table, fresh, term.expr)
      let {fresh, body} = Kindelia.sanitize(world, table, fresh, term.body)
      {fresh, Kindelia.Term.set(term.file, expr, body)}
    get:
      use file = Kindelia.get_file(world, term.file) abort {fresh, term}
      let {table, fresh, name} = Kindelia.rename(table, fresh, term.name)
      let {fresh, body} = Kindelia.sanitize(world, table, fresh, term.body)
      {fresh, Kindelia.Term.get(name, term.file, body)}
    bind:
      let {fresh, expr} = Kindelia.sanitize(world, table, fresh, term.expr)
      let {table, fresh, name} = Kindelia.rename(table, fresh, term.name)
      let {fresh, body} = Kindelia.sanitize(world, table, fresh, term.body)
      {fresh, Kindelia.Term.bind(name, term.type, expr, body)}
    return:
      let {fresh, expr} = Kindelia.sanitize(world, table, fresh, term.expr)
      {fresh, Kindelia.Term.return(expr)}
  }

Kindelia.sanitize.cases(
  world: Kindelia.World
  table: Map<String>
  fresh: Nat
  old_name: String
  new_name: String
  ctrs: List<Kindelia.Constructor>
  cses: List<Kindelia.Term>
): Pair<Nat, List<Kindelia.Term>>
  case ctrs cses {
    nil nil:
      {fresh, []}
    cons cons:
      let new_table = table
      let new_table = for field in ctrs.head@fprm: Map.set!(old_name | "." | field@fst, new_name | "." | field@fst, new_table)
      let {fresh, head} = Kindelia.sanitize(world, new_table, fresh, cses.head)
      let {fresh, tail} = Kindelia.sanitize.cases(world, table, fresh, old_name, new_name, ctrs.tail, cses.tail)
      {fresh, head & tail}
  } default {fresh, []}

Kindelia.sanitize.many(
  world: Kindelia.World
  table: Map<String>
  fresh: Nat
  terms: List<Kindelia.Term>
): Pair<Nat, List<Kindelia.Term>>
  case terms {
    nil:
      {fresh, []}
    cons:
      let {fresh, head} = Kindelia.sanitize(world, table, fresh, terms.head)
      let {fresh, tail} = Kindelia.sanitize.many(world, table, fresh, terms.tail)
      {fresh, head & tail}
  }

// Generates a new name to replace old_name
Kindelia.rename(table: Map<String>, fresh: Nat, old_name: String): Triple<Map<String>, Nat, String>
    let new_name = "$" | Nat.show(fresh)
    let table = Map.set!(old_name, new_name, table)
    let fresh = Nat.succ(fresh)
    {table, fresh, new_name}

Kindelia.rename.many(table: Map<String>, fresh: Nat, names: List<String>): Triple<Map<String>, Nat, List<String>>
  case names {
    nil:
      {table, fresh, []}
    cons:
      let {table, fresh, head} = Kindelia.rename(table, fresh, names.head)
      let {table, fresh, tail} = Kindelia.rename.many(table, fresh, names.tail)
      {table, fresh, head & tail}
  }

// Transaction
// -----------

//Kindelia.reg(
  //world: Kindelia.World
  //transaction: Kindelia.Transaction
//): Kindelia.World
  //Kindelia.run_transaction(world,transaction,true) <> world

Kindelia.transact(
  world: Kindelia.World
  transaction: Kindelia.Transaction
): Maybe<Pair<Kindelia.World,String>>
  case transaction {
    new_data:
      use data = transaction.data
      case world{data.name} as got_type {
        none:
          let world = Map.set!(data.name, Kindelia.Entry.data(data), world)
          some({world, "[data] " | data.name})
      } default none
    new_bond:
      use bond = transaction.bond
      case world{bond.name} as got {
        none:
          let world = Map.set!(bond.name, Kindelia.Entry.bond(bond), world)
          let {inam, ityp} = List.unzip!!(bond.iprm)
          let context = Kindelia.extend<Kindelia.Type>({}, inam, ityp)
          if Kindelia.check(context, world, bond.main, bond.otyp, some(bond.name)) then
            some({world, "[bond] " | bond.name})
          else
            none
      } default
        none
    new_file:
      use file = transaction.file
      case world{file.name} as got {
        none:
          let world = Map.set!(file.name, Kindelia.Entry.file(file), world)
          if Kindelia.check({}, world, file.expr, file.type, none) then
            some({world, "[file] " | file.name})
          else
            none
      } default
        none
    new_eval:
      use eval = transaction.eval
      if Kindelia.check({}, world, eval.term, eval.type, none) then
        let fresh = 0
        let {fresh, term} = Kindelia.sanitize(world, {}, fresh, eval.term)
        let {world, subst, fresh, gas, term} = case eval.type {
          effe: Kindelia.normalize(Kindelia.run({world, {}, fresh, 0, term}))
        } default Kindelia.normalize({world, {}, fresh, 0, term})
        some({world, "[eval] " | Kindelia.show.term(world, term)})
      else
        none
  }

// Serialization
// -------------

Kindelia.serialize.varlen(value: Nat): Bits
  Kindelia.serialize.varlen.go(Nat.add(value,1))

Kindelia.deserialize.varlen(bits: Bits): Pair<Bits,Nat>
  let {bits,value} = Kindelia.deserialize.varlen.go(bits)
  {bits, Nat.sub(value,1)}

Kindelia.serialize.varlen.go(value: Nat): Bits
  case value {
    zero: Bits.e
    succ:
      if Nat.eql(value,1) then
        Bits.o(Bits.e)
      else if Nat.eql(Nat.mod(value,2),0)
        then Bits.i(Bits.o(Kindelia.serialize.varlen.go(Nat.div(value,2))))
        else Bits.i(Bits.i(Kindelia.serialize.varlen.go(Nat.div(value,2))))
  }

Kindelia.deserialize.varlen.go(bits: Bits): Pair<Bits,Nat>
  case bits {
    e: {Bits.e, 0}
    o: {bits.pred, 1}
    i: case bits.pred {
      e: {bits.pred, 0}
      o:
        let {bits,x} = Kindelia.deserialize.varlen.go(bits.pred.pred)
        {bits, Nat.mul(x,2)}
      i:
        let {bits,x} = Kindelia.deserialize.varlen.go(bits.pred.pred)
        {bits, Nat.add(Nat.mul(x,2),1)}
    }
  }

Kindelia.serialize.fixlen(size: Nat, value: Nat): Bits
  case size {
    zero: Bits.e
    succ: if Nat.eql(Nat.mod(value,2),0)
      then Bits.o(Kindelia.serialize.fixlen(size.pred, Nat.div(value,2)))
      else Bits.i(Kindelia.serialize.fixlen(size.pred, Nat.div(value,2)))
  }

Kindelia.deserialize.fixlen(size: Nat, bits: Bits): Pair<Bits,Nat>
  case size {
    zero: {bits, 0}
    succ: case bits {
      e: {Bits.e, 0}
      o:
        let {bits,x} = Kindelia.deserialize.fixlen(size.pred, bits.pred)
        {bits, Nat.mul(x,2)}
      i:
        let {bits,x} = Kindelia.deserialize.fixlen(size.pred, bits.pred)
        {bits, Nat.add(Nat.mul(x,2),1)}
    }
  }

Kindelia.serialize.pair<A: Type, B: Type>(first: A -> Bits, second: B -> Bits, pair: Pair<A, B>): Bits
  open pair
  let fst = first(pair.fst)
  let snd = second(pair.snd)
  Bits.concat(fst, snd)

Kindelia.deserialize.pair<A: Type, B: Type>(first: Bits -> Pair<Bits, A>, second: Bits -> Pair<Bits, B>, bits: Bits): Pair<Bits, Pair<A,B>>
  let {bits, fst} = first(bits)
  let {bits, snd} = second(bits)
  {bits, {fst, snd}}

Kindelia.serialize.list<A: Type>(item: A -> Bits, list: List<A>): Bits
  case list {
    nil: Bits.o(Bits.e)
    cons: Bits.i(Bits.concat(item(list.head), Kindelia.serialize.list<A>(item, list.tail)))
  }

Kindelia.deserialize.list<A: Type>(item: Bits -> Pair<Bits,A>, bits: Bits): Pair<Bits,List<A>>
  case bits {
    e: {Bits.e, []}
    o: {bits.pred, []}
    i:
      let {bits, head} = item(bits.pred)
      let {bits, tail} = Kindelia.deserialize.list<A>(item, bits)
      {bits, head & tail}
  }

Kindelia.serialize.name(name: String): Bits
  case name {
    nil:
      Bits.o(Bits.e)
    cons:
      let numb =
        if U16.btw('0', name.head, '9') then
          U16.sub(name.head, '0')
        else if U16.btw('A', name.head, 'Z') then
          U16.add(U16.sub(name.head, 'A'), 10#16)
        else if U16.btw('a', name.head, 'z') then
          U16.add(U16.sub(name.head, 'a'), 36#16)
        else if U16.btw('_', name.head, '_') then
          62#16
        else
          63#16
      let head = Kindelia.serialize.fixlen(6, U16.to_nat(numb))
      let tail = Kindelia.serialize.name(name.tail)
      Bits.i(Bits.concat(head, tail))
  }

Kindelia.deserialize.name(bits: Bits): Pair<Bits,String>
  case bits {
    e: {Bits.e, ""}
    o: {bits.pred, ""}
    i:
      let {bits, numb} = Kindelia.deserialize.fixlen(6, bits.pred)
      let {bits, tail} = Kindelia.deserialize.name(bits)
      let numb = Nat.to_u16(numb)
      let head =
        if U16.btw( 0, numb,  9) then
          U16.add(numb, '0')
        else if U16.btw(10, numb, 35) then
          U16.add(U16.sub(numb,10#16), 'A')
        else if U16.btw(36, numb, 61) then
          U16.add(U16.sub(numb,36#16), 'a')
        else if U16.btw(62, numb, 62) then
          '_'
        else
          '.'
      {bits, String.cons(head,tail)}
  }

Kindelia.serialize.name.local(world: Kindelia.World, vars: List<String>, name: String): Bits
  case List.find_index!(vars, String.eql(name)) as got {
    none: Bits.e
    some: Kindelia.serialize.varlen(got.value)
  }

Kindelia.deserialize.name.local(world: Kindelia.World, vars: List<String>, bits: Bits): Pair<Bits,String>
  let {bits,numb} = Kindelia.deserialize.varlen(bits)
  {bits, vars[numb] <> ""}

Kindelia.serialize.term(world: Kindelia.World, vars: List<String>, term: Kindelia.Term): Bits
  case term {
    var:
      Bits.o(Kindelia.serialize.name.local(world, vars, term.name))
    let:
      let name = Kindelia.serialize.name(term.name)
      let type = Kindelia.serialize.type(world,term.type) // TODO
      let expr = Kindelia.serialize.term(world,vars,term.expr)
      let body = Kindelia.serialize.term(world,term.name&vars,term.body)
      Bits.i(Bits.o(Bits.o(Bits.o(Bits.concat(name, Bits.concat(type, Bits.concat(expr, body)))))))
    call:
      let bond = Kindelia.serialize.name(term.bond)
      let args = Kindelia.serialize.list!(Kindelia.serialize.term(world,vars), term.args)
      Bits.i(Bits.i(Bits.o(Bits.o(Bits.concat(bond, args)))))
    create:
      let ctor = Kindelia.serialize.name(term.ctor)
      let vals = Kindelia.serialize.list!(Kindelia.serialize.term(world,vars), term.vals)
      Bits.i(Bits.o(Bits.i(Bits.o(Bits.concat(ctor, vals)))))
    match:
      let name = Kindelia.serialize.name.local(world,vars,term.name)
      let data = Kindelia.serialize.name(term.data)
      let cses = Kindelia.serialize.cases(world,vars,term.name,Kindelia.get_constructors(world,term.data)<>[],term.cses)
      Bits.i(Bits.i(Bits.i(Bits.o(Bits.concat(name, Bits.concat(data, cses))))))
    word:
      let numb = Kindelia.serialize.fixlen(64, U64.to_nat(term.numb))
      Bits.i(Bits.o(Bits.o(Bits.i(numb))))
    compare:
      let val0 = Kindelia.serialize.term(world,vars,term.val0)
      let val1 = Kindelia.serialize.term(world,vars,term.val1)
      let iflt = Kindelia.serialize.term(world,vars,term.iflt)
      let ifeq = Kindelia.serialize.term(world,vars,term.ifeq)
      let ifgt = Kindelia.serialize.term(world,vars,term.ifgt)
      Bits.i(Bits.i(Bits.o(Bits.i(Bits.concat(val0, Bits.concat(val1, Bits.concat(iflt, Bits.concat(ifeq, ifgt))))))))
    operate:
      let oper = Kindelia.serialize.fixlen(3, case term.oper { add:0, sub:1, mul:2, div:3, mod:4, or:5, and:6, xor:7 })
      let val0 = Kindelia.serialize.term(world,vars,term.val0)
      let val1 = Kindelia.serialize.term(world,vars,term.val1)
      Bits.i(Bits.o(Bits.i(Bits.i(Bits.concat(oper, Bits.concat(val0, val1))))))
    set:
      let slit = Kindelia.serialize.name(term.file)
      let expr = Kindelia.serialize.term(world,vars,term.expr)
      let body = Kindelia.serialize.term(world,vars,term.body)
      Bits.i(Bits.i(Bits.i(Bits.i(Bits.o(Bits.o(Bits.concat(slit, Bits.concat(expr, body))))))))
    get:
      let slit = Kindelia.serialize.name(term.file)
      let name = Kindelia.serialize.name(term.name)
      let body = Kindelia.serialize.term(world,term.name&vars,term.body)
      Bits.i(Bits.i(Bits.i(Bits.i(Bits.i(Bits.o(Bits.concat(slit, Bits.concat(name, body))))))))
    bind:
      let name = Kindelia.serialize.name(term.name)
      let type = Kindelia.serialize.type(world,term.type) // TODO
      let expr = Kindelia.serialize.term(world,vars,term.expr)
      let body = Kindelia.serialize.term(world,term.name&vars,term.body)
      Bits.i(Bits.i(Bits.i(Bits.i(Bits.o(Bits.i(Bits.concat(name, Bits.concat(type, Bits.concat(expr, body)))))))))
    return:
      let expr = Kindelia.serialize.term(world,vars,term.expr)
      Bits.i(Bits.i(Bits.i(Bits.i(Bits.i(Bits.i(expr))))))
  } default _

Kindelia.deserialize.term(world: Kindelia.World, vars: List<String>, bits: Bits): Pair<Bits,Kindelia.Term>
  case bits {
    o:
      let {bits,name} = Kindelia.deserialize.name.local(world, vars, bits.pred)
      {bits, Kindelia.Term.var(name)}
    i:
      let {bits,ctor} = Kindelia.deserialize.fixlen(3, bits.pred)
      switch Nat.eql(ctor) {
        0:
          let {bits,name} = Kindelia.deserialize.name(bits)
          let {bits,type} = Kindelia.deserialize.type(world,bits)
          let {bits,expr} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,body} = Kindelia.deserialize.term(world,name&vars,bits)
          {bits, Kindelia.Term.let(name,type,expr,body)}
        1:
          let {bits,bond} = Kindelia.deserialize.name(bits)
          let {bits,args} = Kindelia.deserialize.list!(Kindelia.deserialize.term(world,vars), bits)
          {bits, Kindelia.Term.call(bond,args)}
        2:
          let {bits,ctor} = Kindelia.deserialize.name(bits)
          let {bits,vals} = Kindelia.deserialize.list!(Kindelia.deserialize.term(world,vars), bits)
          {bits, Kindelia.Term.create(ctor, vals)}
        3:
          let {bits,name} = Kindelia.deserialize.name.local(world,vars,bits)
          let {bits,data} = Kindelia.deserialize.name(bits)
          let {bits,cses} = Kindelia.deserialize.cases(world,vars,name,Kindelia.get_constructors(world,data)<>[],bits)
          {bits, Kindelia.Term.match(name,data,cses)}
        4:
          let {bits,numb} = Kindelia.deserialize.fixlen(64,bits)
          {bits, Kindelia.Term.word(Nat.to_u64(numb))}
        5:
          let {bits,val0} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,val1} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,iflt} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,ifeq} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,ifgt} = Kindelia.deserialize.term(world,vars,bits)
          {bits, Kindelia.Term.compare(val0,val1,iflt,ifeq,ifgt)}
        6:
          let {bits,oper} = Kindelia.deserialize.fixlen(3, bits)
          let {bits,val0} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,val1} = Kindelia.deserialize.term(world,vars,bits)
          let oper = switch Nat.eql(oper) {
            0: Kindelia.Operation.add
            1: Kindelia.Operation.sub
            2: Kindelia.Operation.mul
            3: Kindelia.Operation.div
            4: Kindelia.Operation.mod
            5: Kindelia.Operation.or
            6: Kindelia.Operation.and
            7: Kindelia.Operation.xor
          } default Kindelia.Operation.add
          {bits, Kindelia.Term.operate(oper, val0, val1)}
        7:
          let {bits,ctor} = Kindelia.deserialize.fixlen(2, bits)
          switch Nat.eql(ctor) {
            0:
              let {bits,file} = Kindelia.deserialize.name(bits)
              let {bits,expr} = Kindelia.deserialize.term(world,vars,bits)
              let {bits,body} = Kindelia.deserialize.term(world,vars,bits)
              {bits, Kindelia.Term.set(file,expr,body)}
            1:
              let {bits,file} = Kindelia.deserialize.name(bits)
              let {bits,name} = Kindelia.deserialize.name(bits)
              let {bits,body} = Kindelia.deserialize.term(world,name&vars,bits)
              {bits, Kindelia.Term.get(name,file,body)}
            2:
              let {bits,name} = Kindelia.deserialize.name(bits)
              let {bits,type} = Kindelia.deserialize.type(world,bits)
              let {bits,expr} = Kindelia.deserialize.term(world,vars,bits)
              let {bits,body} = Kindelia.deserialize.term(world,name&vars,bits)
              {bits, Kindelia.Term.bind(name,type,expr,body)}
            3:
              let {bits,expr} = Kindelia.deserialize.term(world,vars,bits)
              {bits, Kindelia.Term.return(expr)}
          } default {bits, Kindelia.Term.word(0)}
      } default {bits, Kindelia.Term.word(0)}
  } default {bits, Kindelia.Term.word(0)}

Kindelia.serialize.cases(
  world: Kindelia.World
  vars: List<String>
  name: String
  ctors: List<Kindelia.Constructor>
  cases: List<Kindelia.Term>
): Bits
  case ctors cases {
    nil nil:
      Bits.e
    cons cons:
      let flds = List.map!!((fprm) name|"."|fprm@fst, ctors.head@fprm)
      let head = Kindelia.serialize.term(world, List.reverse!(flds) ++ vars, cases.head)
      let tail = Kindelia.serialize.cases(world, vars, name, ctors.tail, cases.tail)
      Bits.concat(head, tail)
  } default Bits.e

Kindelia.deserialize.cases(
  world: Kindelia.World
  vars: List<String>
  name: String
  ctors: List<Kindelia.Constructor>
  bits: Bits
): Pair<Bits, List<Kindelia.Term>>
  case ctors {
    nil:
      {bits, []}
    cons:
      let flds = List.map!!((fprm) name|"."|fprm@fst, ctors.head@fprm)
      let {bits,head} = Kindelia.deserialize.term(world, List.reverse!(flds) ++ vars, bits)
      let {bits,tail} = Kindelia.deserialize.cases(world, vars, name, ctors.tail, bits)
      {bits, head & tail}
  }

Kindelia.serialize.type(world: Kindelia.World, typ: Kindelia.Type): Bits
  case typ {
    word: Bits.o(Bits.o(Bits.e))
    data: Bits.i(Bits.o(Kindelia.serialize.name(typ.name)))
    effe: Bits.o(Bits.i(Kindelia.serialize.type(world,typ.rety)))
  }

Kindelia.deserialize.type(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Type>
  let {bits,ctor} = Kindelia.deserialize.fixlen(2, bits)
  switch Nat.eql(ctor) {
    0:
      {bits, Kindelia.Type.word}
    1:
      let {bits,name} = Kindelia.deserialize.name(bits)
      {bits, Kindelia.Type.data(name)}
    2:
      let {bits,rety} = Kindelia.deserialize.type(world, bits)
      {bits, Kindelia.Type.effe(rety)}
  } default {bits, Kindelia.Type.word}

Kindelia.serialize.data(world: Kindelia.World, data: Kindelia.Data): Bits
  open data
  let name = Kindelia.serialize.name(data.name)
  let ctrs = Kindelia.serialize.list!(Kindelia.serialize.constructor(world), data.constructors)
  Bits.concat(name, ctrs)

Kindelia.deserialize.data(world: Kindelia.World, bits: Bits): Pair<Bits, Kindelia.Data>
  let {bits,name} = Kindelia.deserialize.name(bits)
  let {bits,ctrs} = Kindelia.deserialize.list!(Kindelia.deserialize.constructor(world), bits)
  {bits, Kindelia.Data.new(name,ctrs)}

Kindelia.serialize.constructor(world: Kindelia.World, ctor: Kindelia.Constructor): Bits
  open ctor
  let name = Kindelia.serialize.name(ctor.name)
  let fprm = Kindelia.serialize.list!(
    Kindelia.serialize.pair!!(Kindelia.serialize.name, Kindelia.serialize.type(world)),
    ctor.fprm
  )
  Bits.concat(name, fprm)
  
Kindelia.deserialize.constructor(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Constructor>
  let {bits,name} = Kindelia.deserialize.name(bits)
  let {bits,fprm} = Kindelia.deserialize.list!(
    Kindelia.deserialize.pair!!(Kindelia.deserialize.name, Kindelia.deserialize.type(world)),
    bits
  )
  {bits, Kindelia.Constructor.new(name, fprm)}

Kindelia.serialize.bond(world: Kindelia.World, bond: Kindelia.Bond): Bits
  open bond
  let name = Kindelia.serialize.name(bond.name)
  let iprm = Kindelia.serialize.list!(
    Kindelia.serialize.pair!!(Kindelia.serialize.name, Kindelia.serialize.type(world)),
    bond.iprm
  )
  let otyp = Kindelia.serialize.type(world, bond.otyp)
  let inam = List.reverse!(List.mapped!(bond.iprm)!(Pair.fst!!))
  let main = Kindelia.serialize.term(world, inam, bond.main)
  Bits.concat(name, Bits.concat(iprm, Bits.concat(otyp, main)))

Kindelia.deserialize.bond(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Bond>
  let {bits,name} = Kindelia.deserialize.name(bits)
  let {bits,iprm} = Kindelia.deserialize.list!(
    Kindelia.deserialize.pair!!(Kindelia.deserialize.name, Kindelia.deserialize.type(world)),
    bits
  )
  let {bits,otyp} = Kindelia.deserialize.type(world, bits)
  let inam = List.reverse!(List.mapped!(iprm)!(Pair.fst!!))
  let {bits,main} = Kindelia.deserialize.term(world, inam, bits)
  {bits, Kindelia.Bond.new(name, iprm, otyp, main)}

Kindelia.serialize.file(world: Kindelia.World, file: Kindelia.File): Bits
  open file
  let name = Kindelia.serialize.name(file.name)
  let ownr = Kindelia.serialize.list!(Kindelia.serialize.name, file.ownr)
  let type = Kindelia.serialize.type(world, file.type)
  let expr = Kindelia.serialize.term(world, [], file.expr)
  Bits.concat(name, Bits.concat(ownr, Bits.concat(type, expr)))

Kindelia.deserialize.file(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.File>
  let {bits,name} = Kindelia.deserialize.name(bits)
  let {bits,ownr} = Kindelia.deserialize.list!(Kindelia.deserialize.name, bits)
  let {bits,type} = Kindelia.deserialize.type(world, bits)
  let {bits,expr} = Kindelia.deserialize.term(world, [], bits)
  {bits, Kindelia.File.new(name, ownr, type, expr)}

Kindelia.serialize.transaction(world: Kindelia.World, transaction: Kindelia.Transaction): Bits
  case transaction {
    new_data:
      let data = Kindelia.serialize.data(world, transaction.data)
      Bits.o(Bits.o(data))
    new_bond:
      let bond = Kindelia.serialize.bond(world, transaction.bond)
      Bits.i(Bits.o(bond))
    new_file:
      let file = Kindelia.serialize.file(world, transaction.file)
      Bits.o(Bits.i(file))
    new_eval:
      let term = Kindelia.serialize.eval(world, transaction.eval)
      Bits.i(Bits.i(term))
  }

Kindelia.deserialize.transaction(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Transaction>
  let {bits,ctor} = Kindelia.deserialize.fixlen(2, bits)
  switch Nat.eql(ctor) {
    0:
      let {bits,data} = Kindelia.deserialize.data(world, bits)
      {bits, Kindelia.Transaction.new_data(data)}
    1:
      let {bits,bond} = Kindelia.deserialize.bond(world, bits)
      {bits, Kindelia.Transaction.new_bond(bond)}
    2:
      let {bits,file} = Kindelia.deserialize.file(world, bits)
      {bits, Kindelia.Transaction.new_file(file)}
    3:
      let {bits,eval} = Kindelia.deserialize.eval(world, bits)
      {bits, Kindelia.Transaction.new_eval(eval)}
  } default {bits, Kindelia.Transaction.new_data(Kindelia.Data.new("",[]))}

Kindelia.serialize.eval(world: Kindelia.World, eval: Kindelia.Eval): Bits
  open eval
  let term = Kindelia.serialize.term(world, [], eval.term)
  let type = Kindelia.serialize.type(world, eval.type)
  Bits.concat(term, type)

Kindelia.deserialize.eval(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Eval>
  let {bits,term} = Kindelia.deserialize.term(world, [], bits)
  let {bits,type} = Kindelia.deserialize.type(world, bits)
  {bits, Kindelia.Eval.new(term,type)}

Kindelia.serialize.block(world: Kindelia.World, block: List<Kindelia.Transaction>): Bits
  case block {
    nil:
      Bits.e
    cons:
      let head = Kindelia.serialize.transaction(world, block.head)
      let tail = Kindelia.serialize.block(world, block.tail)
      Bits.concat(head, tail)
  }

Kindelia.deserialize.block(world: Kindelia.World, bits: Bits): Pair<Bits, List<Kindelia.Transaction>>
  if Bits.is_empty(bits) then
    {Bits.e, []}
  else
    let {bits,head} = Kindelia.deserialize.transaction(world, bits)
    let {bits,tail} = Kindelia.deserialize.block(world, bits)
    {bits, head & tail}


// Stringification
// ---------------

Kindelia.show.term(
  world: Kindelia.World
  term: Kindelia.Term
): String
  case term {
    var:
      term.name
    let:
      let name = term.name
      let type = Kindelia.show.type(world, term.type)
      let expr = Kindelia.show.term(world, term.expr)
      let body = Kindelia.show.term(world, term.body)
      "let " | name | " : " | type | " = " | expr | " " | body
    create:
      let vals = List.mapped!(term.vals)!(Kindelia.show.term(world))
      term.ctor | "{" | String.join(",",vals) | "}"
    match:
      use data = Kindelia.get_data(world, term.data) abort "?"
      let name = term.name
      let cses = List.zipped_with!!(data.constructors, term.cses)!((case_ctor, case_body)
        case_ctor@name | ": " | Kindelia.show.term(world, case_body))
      "case " | name | " : " | term.data | " { " | String.join(", ", cses) | " }"
    word:
      "#" | U64.show(term.numb)
    compare:
      let val0 = Kindelia.show.term(world, term.val0)
      let val1 = Kindelia.show.term(world, term.val1)
      let iflt = Kindelia.show.term(world, term.iflt)
      let ifeq = Kindelia.show.term(world, term.ifeq)
      let ifgt = Kindelia.show.term(world, term.ifgt)
      "compare " | val0 | " " | val1 | " { _<_: " | iflt | " _=_: " | ifeq | " _>_: " | ifgt | " }"
    operate:
      let oper = case term.oper { add: "+", sub: "-", mul: "*", div: "/", mod: "%", or: "|", and: "&", xor: "^" }
      let val0 = Kindelia.show.term(world, term.val0)
      let val1 = Kindelia.show.term(world, term.val1)
      oper | "(" | val0 | "," | val1 | ")"
    call:
      let bond = term.bond
      let args = List.map!!(Kindelia.show.term(world), term.args)
      bond | "(" | String.join(",", args) | ")"
    set:
      let file = term.file
      let expr = Kindelia.show.term(world, term.expr)
      let body = Kindelia.show.term(world, term.body)
      "set " | file | " = " | expr | "; " | body
    get:
      let file = term.file
      let name = term.name
      let body = Kindelia.show.term(world, term.body)
      "get " | name | " = " | file | "; " | body
    bind:
      let name = term.name
      let type = Kindelia.show.type(world, term.type)
      let expr = Kindelia.show.term(world, term.expr)
      let body = Kindelia.show.term(world, term.body)
      if String.is_empty(name) then
        "run " | expr | "; " | body
      else
        "run " | name | " : " | type | " = " | expr | "; " | body
    return:
      let expr = Kindelia.show.term(world, term.expr)
      "return " | expr
  }

Kindelia.show.type(
  world: Kindelia.World
  type: Kindelia.Type
): String
  case type {
    word: "#word"
    data: type.name
    effe: "& " | Kindelia.show.type(world,type.rety)
  }

Kindelia.show.data(
  world: Kindelia.World
  data: Kindelia.Data
): String
  open data
  "data " | data.name | " { "
  | String.join(", ", List.mapped!(data.constructors)!((Kindelia.show.constructor(world))))
  | " }"

Kindelia.show.constructor(
  world: Kindelia.World
  constructor: Kindelia.Constructor
): String
  open constructor
  let fields = List.mapped!(constructor.fprm)!(
    (fprm) 
      fprm@fst | ": " | Kindelia.show.type(world, fprm@snd)
  )
  constructor.name | "{" | String.join(", ", fields) | "}"

Kindelia.show.bond(
  world: Kindelia.World
  bond: Kindelia.Bond
): String
  open bond
  "bond "
  | bond.name
  | "("
  | String.join(",", List.mapped!(bond.iprm)!((x) x@fst | ": " | Kindelia.show.type(world, x@snd)))
  | "): "
  | Kindelia.show.type(world,bond.otyp)
  | " { "
  | Kindelia.show.term(world,bond.main)
  | " }"

Kindelia.show.file(
  world: Kindelia.World
  file: Kindelia.File
): String
  open file
  "file "
  | String.join(" ", List.map!!((x) x|"@", file.ownr))
  | file.name
  | " : "
  | Kindelia.show.type(world,file.type)
  | " = "
  | Kindelia.show.term(world,file.expr)

Kindelia.show.entry(
  world: Kindelia.World
  entry: Kindelia.Entry
): String
  case entry {
    data: Kindelia.show.data(world, entry.value)
    bond: Kindelia.show.bond(world, entry.value)
    file: Kindelia.show.file(world, entry.value)
  } | "\n"

Kindelia.show.eval(
  world: Kindelia.World
  eval: Kindelia.Eval
): String
  open eval
  let term = Kindelia.show.term(world, eval.term)
  let type = Kindelia.show.type(world, eval.type)
  "eval {" | term | "} : " | type

Kindelia.show.transaction(
  world: Kindelia.World
  transaction: Kindelia.Transaction
): String
  case transaction {
    new_data: Kindelia.show.data(world, transaction.data)
    new_bond: Kindelia.show.bond(world, transaction.bond)
    new_file: Kindelia.show.file(world, transaction.file)
    new_eval: Kindelia.show.eval(world, transaction.eval)
  }

Kindelia.show.block(
  world: Kindelia.World
  block: List<Kindelia.Transaction>
): String
  case block {
    nil:
      ""
    cons:
      let head = Kindelia.show.transaction(world, block.head)
      let tail = Kindelia.show.block(world, block.tail)
      "- " | head | "\n" | tail
  }

// Parsing
// -------

Kindelia.parse.ignore: Parser(List<Unit>)
 Parser.many!(Parser.choice!([
   Parser.text(" ")
   Parser.text("\t")
   Parser.text("\r")
   Parser.text("\n")
   Parser {
     Parser.text("//")
     let end = Parser.choice!([Parser.text("\n"), Parser.eof])
     Parser.until!(end, Parser.one)
     return unit
   }
 ]))

Kindelia.parse.text(text: String): Parser(Unit)
  Parser {
    Kindelia.parse.ignore
    Parser.text(text)
  }

Kindelia.parse.name: Parser<String>
 Parser {
   Kindelia.parse.ignore
   get fst_chr = Kindelia.parse.letter
   get chrs = Parser.many<Kind.Letter>(Kindelia.parse.letter)
   return String.cons(fst_chr, List.fold!(chrs)!(String.nil, String.cons))
 }

Kindelia.parse.letter: Parser<Char>
  Parser.letter((chr)
    if      U16.btw('A', chr, 'Z') then Bool.true
    else if U16.btw('a', chr, 'z') then Bool.true
    else if U16.btw('0', chr, '9') then Bool.true
    else if U16.eql('.', chr)      then Bool.true
    else if U16.eql('_', chr)      then Bool.true
    else if U16.eql('^', chr)      then Bool.true
    else                                Bool.false)

Kindelia.parse.term(world: Kindelia.World): Parser<Kindelia.Term>
 Parser.choice!([
    Kindelia.parse.term.let(world)
    Kindelia.parse.term.create(world)
    Kindelia.parse.term.match(world)
    Kindelia.parse.term.word(world)
    Kindelia.parse.term.compare(world)
    Kindelia.parse.term.operate(world)
    Kindelia.parse.term.set(world)
    Kindelia.parse.term.get(world)
    Kindelia.parse.term.bind(world)
    Kindelia.parse.term.return(world)
    Kindelia.parse.term.call(world)
    Kindelia.parse.term.var(world)
 ])

Kindelia.parse.term.let(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("let")
    get name = Kindelia.parse.name
    Kindelia.parse.text(":")
    get type = Kindelia.parse.type(world)
    Kindelia.parse.text("=")
    get expr = Kindelia.parse.term(world)
    Parser.maybe!(Kindelia.parse.text(";"))
    get body = Kindelia.parse.term(world)
    return Kindelia.Term.let(name, type, expr, body)
 }

Kindelia.parse.term.create(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    get ctor = Kindelia.parse.name
    get vals = Parser.wrap!(
      Kindelia.parse.text("{")
      Parser {
        get val = Kindelia.parse.term(world)
        Parser.maybe!(Kindelia.parse.text(","))
        return val
      }
      Kindelia.parse.text("}"))
    return Kindelia.Term.create(ctor, vals)
 }

Kindelia.parse.term.match(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("case ")
    get name = Kindelia.parse.name
    Kindelia.parse.text(":")
    get data_name = Kindelia.parse.name
    case Kindelia.get_data(world, data_name) as found {
      none: Parser.fail!("Type not found.")
      some: Parser {
        use data = found.value
        Kindelia.parse.text("{")
        get cses = Kindelia.parse.term.match.cases(world, data.constructors)
        Kindelia.parse.text("}")
        return Kindelia.Term.match(name, data_name, cses)
      }
    }
  }

Kindelia.parse.term.match.cases(
  world: Kindelia.World
  constructors: List<Kindelia.Constructor>
): Parser<List<Kindelia.Term>>
 case constructors {
   nil: Parser {
     return []
   }
   cons: Parser {
     use ctor = constructors.head
     Kindelia.parse.text(ctor.name)
     Kindelia.parse.text(":")
     get head = Kindelia.parse.term(world)
     Parser.maybe!(Kindelia.parse.text(","))
     get tail = Kindelia.parse.term.match.cases(world, constructors.tail)
     return head & tail
   }
 }

Kindelia.parse.term.word(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("#")
    get num = Parser.nat
    if Nat.gte(num,Nat.pow(2,64)) then
      Parser.fail!("Number out of bound")
    else Parser {
      return Kindelia.Term.word(Nat.to_u64(num))
    }
  }

Kindelia.parse.term.compare(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("compare")
    get val0 = Kindelia.parse.term(world)
    get val1 = Kindelia.parse.term(world)
    Kindelia.parse.text("{")
    Kindelia.parse.text("_<_:")
    get iflt = Kindelia.parse.term(world)
    Kindelia.parse.text("_=_:")
    get ifeq = Kindelia.parse.term(world)
    Kindelia.parse.text("_>_:")
    get ifgt = Kindelia.parse.term(world)
    Kindelia.parse.text("}")
    return Kindelia.Term.compare(val0, val1, iflt, ifeq, ifgt)
  }

Kindelia.parse.term.operate(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    get oper = Kindelia.parse.term.operation
    case oper {
      none: Parser.fail!("Not an operation.")
      some: Parser {
        Kindelia.parse.text("(")
        get val0 = Kindelia.parse.term(world)
        Parser.maybe!(Kindelia.parse.text(","))
        get val1 = Kindelia.parse.term(world)
        Kindelia.parse.text(")")
        return Kindelia.Term.operate(oper.value, val0, val1)
      }
    }
  }

Kindelia.parse.term.operation: Parser<Maybe<Kindelia.Operation>>
  Parser.choice!([
    Parser {
      Kindelia.parse.text("+")
      return some(Kindelia.Operation.add)
    }
    Parser {
      Kindelia.parse.text("-")
      return some(Kindelia.Operation.sub)
    }
    Parser {
      Kindelia.parse.text("*")
      return some(Kindelia.Operation.mul)
    }
    Parser {
      Kindelia.parse.text("/")
      return some(Kindelia.Operation.div)
    }
    Parser {
      Kindelia.parse.text("%")
      return some(Kindelia.Operation.mod)
    }
    Parser {
      Kindelia.parse.text("|")
      return some(Kindelia.Operation.or)
    }
    Parser {
      Kindelia.parse.text("&")
      return some(Kindelia.Operation.and)
    }
    Parser {
      Kindelia.parse.text("^")
      return some(Kindelia.Operation.xor)
    }
    Parser {
      return none
    }
  ])

Kindelia.parse.term.bind(world: Kindelia.World): Parser<Kindelia.Term>
  Parser.choice!([
    Parser {
      Kindelia.parse.text("run")
      get name = Kindelia.parse.name
      Kindelia.parse.text(":")
      get type = Kindelia.parse.type(world)
      Kindelia.parse.text("=")
      get expr = Kindelia.parse.term(world)
      Parser.maybe!(Kindelia.parse.text(";"))
      get body = Kindelia.parse.term(world)
      return Kindelia.Term.bind(name, type, expr, body)
    }
    Parser {
      Kindelia.parse.text("run")
      get expr = Kindelia.parse.term(world)
      Parser.maybe!(Kindelia.parse.text(";"))
      get body = Kindelia.parse.term(world)
      return Kindelia.Term.bind("", Kindelia.Type.word, expr, body)
    }
  ])

Kindelia.parse.term.set(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("set")
    get bond = Kindelia.parse.name
    Kindelia.parse.text("=")
    get main = Kindelia.parse.term(world)
    Parser.maybe!(Kindelia.parse.text(";"))
    get body = Kindelia.parse.term(world)
    return Kindelia.Term.set(bond, main, body)
  }

Kindelia.parse.term.get(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("get")
    get name = Kindelia.parse.name
    Kindelia.parse.text("=")
    get file = Kindelia.parse.name
    Parser.maybe!(Kindelia.parse.text(";"))
    get body = Kindelia.parse.term(world)
    return Kindelia.Term.get(name, file, body)
  }

Kindelia.parse.term.return(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("return")
    get expr = Kindelia.parse.term(world)
    return Kindelia.Term.return(expr)
  }

Kindelia.parse.term.call(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    get ctor = Kindelia.parse.name
    get args = Parser.wrap!(
      Kindelia.parse.text("(")
      Parser {
        get val = Kindelia.parse.term(world)
        Parser.maybe!(Kindelia.parse.text(","))
        return val
      }
      Kindelia.parse.text(")"))
    return Kindelia.Term.call(ctor, args)
 }

Kindelia.parse.term.var(
  world: Kindelia.World
): Parser<Kindelia.Term>
 Parser {
   get name = Kindelia.parse.name
   return Kindelia.Term.var(name)
 }

Kindelia.parse.type(
  world: Kindelia.World
): Parser<Kindelia.Type>
  Parser.choice!([
    Parser {
      Kindelia.parse.text("&")
      get rety = Kindelia.parse.type(world)
      return Kindelia.Type.effe(rety)
    }
    Parser {
      Kindelia.parse.text("#word")
      return Kindelia.Type.word
    }
    Parser {
      get name = Kindelia.parse.name
      return Kindelia.Type.data(name)
    }
  ])

Kindelia.parse.data(world: Kindelia.World): Parser<Kindelia.Data>
  Parser {
    Kindelia.parse.text("type")
    get name = Kindelia.parse.name
    get ctors = Parser.wrap!(
      Kindelia.parse.text("{")
      Parser {
        get val = Kindelia.parse.constructor(world)
        Parser.maybe!(Kindelia.parse.text(","))
        return val
      }
      Kindelia.parse.text("}")
    )
    return Kindelia.Data.new(name, ctors)
  }
  
Kindelia.parse.constructor(world: Kindelia.World): Parser<Kindelia.Constructor>
 Parser {
   get name = Kindelia.parse.name
   get fprm = Parser.wrap!(
      Kindelia.parse.text("{")
      Kindelia.parse.ann(world)
      Kindelia.parse.text("}"))
   return Kindelia.Constructor.new(name, fprm)
 }

Kindelia.parse.bond(world: Kindelia.World): Parser<Kindelia.Bond>
  Parser {
    Kindelia.parse.text("bond")
    get name = Kindelia.parse.name
    get iprm = Parser.wrap!(
      Kindelia.parse.text("(")
      Kindelia.parse.ann(world)
      Kindelia.parse.text(")"))
    Kindelia.parse.text(":")
    get otyp = Kindelia.parse.type(world)
    Kindelia.parse.text("{")
    get main = Kindelia.parse.term(world)
    Kindelia.parse.text("}")
    return Kindelia.Bond.new(name, iprm, otyp, main)
  }

Kindelia.parse.file(world: Kindelia.World): Parser<Kindelia.File>
  Parser {
    Kindelia.parse.text("file")
    get ownr = Parser.maybe!(
      Parser {
        get ownr = Parser.many!(Parser {
          get name = Kindelia.parse.name
          Parser.maybe!(Kindelia.parse.text(","))
          return name
        })
        case ownr {
          nil:  Parser { return [] }
          cons: Parser { 
            Kindelia.parse.text("@") 
            return ownr 
          }
        }
      }
    )
    let ownr = ownr <> []
    get name = Kindelia.parse.name
    Kindelia.parse.text(":")
    get type = Kindelia.parse.type(world)
    Kindelia.parse.text("=")
    get expr = Kindelia.parse.term(world)
    return Kindelia.File.new(name, ownr, type, expr)
  }

Kindelia.parse.ann(world: Kindelia.World): Parser<Pair<String,Kindelia.Type>>
 Parser {
    Parser.maybe!(Kindelia.parse.text(","))
    get name = Kindelia.parse.name
    Kindelia.parse.text(":")
    get type = Kindelia.parse.type(world)
    return {name, type}
 }

Kindelia.parse.eval(world: Kindelia.World): Parser<Kindelia.Eval>
  Parser {
    Kindelia.parse.text("eval")
    Kindelia.parse.text("{")
    get term = Kindelia.parse.term(world)
    Kindelia.parse.text("}")
    Kindelia.parse.text(":")
    get type = Kindelia.parse.type(world)
    return Kindelia.Eval.new(term, type)
  }

Kindelia.parse.transaction(world: Kindelia.World): Parser<Kindelia.Transaction>
  Parser.choice!([
    Parser {
      get data = Kindelia.parse.data(world)
      return Kindelia.Transaction.new_data(data)
    }
    Parser {
      get bond = Kindelia.parse.bond(world)
      return Kindelia.Transaction.new_bond(bond)
    }
    Parser {
      get file = Kindelia.parse.file(world)
      return Kindelia.Transaction.new_file(file)
    }
    Parser {
      get term = Kindelia.parse.eval(world)
      return Kindelia.Transaction.new_eval(term)
    }
  ])

Kindelia.parse.block(world: Kindelia.World): Parser<List<Kindelia.Transaction>>
  Parser.until!(Kindelia.parse.text("save"), Kindelia.parse.transaction(world))

// API
// ---

Kindelia.api.run(code: String): IO<Unit>
  Kindelia.api.run.go(Kindelia.genesis, 0, code)

Kindelia.api.run.go(
  world: Kindelia.World
  block_number: Nat
  code: String
): IO<Unit>
  let parsed = Kindelia.parse.block(world, Parser.State.new(none, "", 0, 0, code))
  case parsed {
    error: IO {
      open parsed.err
      if Nat.ltn(parsed.err.idx, String.length(code)) then IO {
        let err = parsed.err.msg | (case parsed.err.nam { nil: "", cons: " Inside " | parsed.err.nam | ":" })
        let hig = Kind.Code.highlight(code, parsed.err.ini, parsed.err.idx, Nat.succ(parsed.err.idx))
        let str = String.flatten([err, "\n", hig])
        IO.print("Error parsing block #" | Nat.show(block_number))
        IO.print(str)
      } else IO {
        IO.print("Done.")
      }
    }
    value: IO {
      let block = parsed.val
      IO.print("Block #" | Nat.show(block_number))
      let bits_0 = Kindelia.serialize.block(world, block)
      let bits_1 = Kindelia.serialize.block(world, Kindelia.deserialize.block(world, bits_0)@snd)
      IO.print("$ " | Bits.hex.encode(bits_0) | " " | if Bits.eql(bits_0,bits_1) then "ok" else "bad_serialization")
      Kindelia.api.run.go.transactions(world, block_number, parsed.pst@str, block)
    }
  }

Kindelia.api.run.go.transactions(
  world: Kindelia.World
  block_number: Nat
  code: String
  transactions: List<Kindelia.Transaction>
): IO<Unit>
  case transactions {
    nil: IO {
      IO.print("")
      Kindelia.api.run.go(world, Nat.succ(block_number), code)
    }
    cons: case Kindelia.transact(world, transactions.head) as result {
      none: IO {
        IO.print("- [fail]")
        Kindelia.api.run.go.transactions(world, block_number, code, transactions.tail)
      }
      some: IO {
        let {world, message} = result.value
        IO.print("- " | message)
        Kindelia.api.run.go.transactions(world, block_number, code, transactions.tail)
      }
    }
  }

Kindelia: _
  IO {
    let x = Kindelia.api.run
    return unit
  }

