// Kindelia: a minimal decentralized computer
// ==========================================

// TODO:
// - lazy sanitize
// - owner

// Types
// -----

// A Kindelia term
type Kindelia.Term {
  // A variable
  var(
    name: String
  )
  // Assigns a variable
  let(
    name: String
    type: Kindelia.Type
    expr: Kindelia.Term
    body: Kindelia.Term
  )
  // Call external function
  call(
    bond: String
    args: List<Kindelia.Term>
  )
  // Creates a value
  create(
    ctor: Nat
    vals: List<Kindelia.Term>
  )
  // Pattern-matches a value
  match(
    name: String
    data: String
    cses: List<Kindelia.Term>
  )
  // Creates a new 64-bit word
  word(
    numb: U64
  )
  // Compares two words
  compare(
    val0: Kindelia.Term
    val1: Kindelia.Term
    iflt: Kindelia.Term
    ifeq: Kindelia.Term
    ifgt: Kindelia.Term
  )
  // Binary operation on words
  operate(
    oper: Kindelia.Operation
    val0: Kindelia.Term
    val1: Kindelia.Term
  )
  // Binds a top-level definition
  bind(
    bond: String
    expr: Kindelia.Term
    cont: Kindelia.Term
  )
}

// A binary operation on words
type Kindelia.Operation {
  add sub mul div mod or and xor
}

// A type reference
type Kindelia.Type {
  word
  data(name: String)
}

// A list of arguments
Kindelia.Args: Type
  List<Pair<String, Kindelia.Type>>

// A global algebraic datatype (ADT) declaration
type Kindelia.Data {
  new(
    name: String
    ctrs: List<Kindelia.Constructor>
  )
}

// An ADT's constructor
type Kindelia.Constructor {
  new(
    name: String
    args: Kindelia.Args
  )
}

// A global function
type Kindelia.Bond {
  new(
    name: String
    ownr: List<String>
    args: Kindelia.Args
    otyp: Kindelia.Type
    main: Kindelia.Term
  )
}

// An authentication call
type Kindelia.Auth {
  new(
    bond: String
    args: List<Kindelia.Term>
  )
}

// An evaluation
type Kindelia.Eval {
  new(
    auth: Maybe<Kindelia.Auth>
    term: Kindelia.Term
    type: Kindelia.Type
  )
}

// A global entry
type Kindelia.Entry {
  data(value: Kindelia.Data)
  bond(value: Kindelia.Bond)
}

// A Kindelia transaction
type Kindelia.Transaction {
  new_data(data: Kindelia.Data)
  new_bond(bond: Kindelia.Bond)
  new_eval(eval: Kindelia.Eval)
  new_name(name: String)
}

type Kindelia.Names {
  new(
    size: Nat
    numb: Map<Nat>
    name: Map<String>
  )
}

type Kindelia.World {
  new(
    names: Kindelia.Names
    entry: Map<Kindelia.Entry>
  )
}

type Kindelia.Runtime <A: Type> {
  new(
    world: Kindelia.World
    subst: Map<Kindelia.Term>
    fresh: Nat
    costs: Nat
    value: A
  )
}

// Utils
// -----

Kindelia.get_data(world: Kindelia.World, name: String): Maybe<Kindelia.Data>
  Maybe {
    get entry = world@entry{name}
    case entry {
      data: some(entry.value)
    } default none
  }

Kindelia.get_bond(world: Kindelia.World, name: String): Maybe<Kindelia.Bond>
  Maybe {
    get entry = world@entry{name}
    case entry {
      bond: some(entry.value)
    } default none
  }

Kindelia.get_ctrs(world: Kindelia.World, name: String): Maybe<List<Kindelia.Constructor>>
  case Kindelia.get_data(world, name) as got {
    none: none
    some: some(got.value@ctrs)
  }

Kindelia.extend<A: Type>(map: Map<A>, kvs: List<Pair<String,A>>): Map<A>
  case kvs {
    nil: map
    cons: Kindelia.extend<A>(map{kvs.head@fst} <- kvs.head@snd, kvs.tail)
  }

Kindelia.call_list(vals: List<Kindelia.Term>, args: List<Pair<String,Kindelia.Type>>): List<Pair<Kindelia.Term,Kindelia.Type>>
  case vals args {
    cons cons: List.cons!({vals.head, args.head@snd}, Kindelia.call_list(vals.tail, args.tail))
  } default []

Kindelia.case_list(name: String, ctrs: List<Kindelia.Constructor>, cses: List<Kindelia.Term>): List<Pair<Kindelia.Args,Kindelia.Term>>
  case ctrs cses {
    cons cons:
      let args = [for arg in ctrs.head@args: {name | "." | arg@fst, arg@snd}]
      let body = cses.head
      let rest = Kindelia.case_list(name, ctrs.tail, cses.tail)
      {args, body} & rest
  } default []

//Kindelia.names(args: List<Pair<String,Kindelia.Type>>): List<A>
  //case args {
    //nil: []
    //cons: List.cons!(args.head@fst, args.tail)
  //}

//Kindelia.types(args: List<Pair<String,Kindelia.Type>>): List<A>
  //case args {
    //nil: []
    //cons: List.cons!(args.head@snd, args.tail)
  //}

// Type-Checking
// -------------

Kindelia.equal(a: Kindelia.Type, b: Kindelia.Type): Bool
  case a b {
    word word: true
    data data: String.eql(a.name, b.name)
  } default false

Kindelia.check(
  context: Map<Kindelia.Type>
  world: Kindelia.World
  term: Kindelia.Term
  type: Kindelia.Type
): Bool
  open context
  //log("-- chk " | Kindelia.show.term(world,type,term) | " : " | Kindelia.show.type(world,type))
  //log("-- ctx: " | String.join(", ", List.map!!((a) a@fst|":"|Kindelia.show.type(world,a@snd), Map.to_list!(context))))  // DEBUG
  //log("")  // DEBUG
  case term {
    var: case context{term.name} as got {
      none: false
      some: Kindelia.equal(got.value, type)
    }
    let:
      let expr = Kindelia.check(context, world, term.expr, term.type)
      let body = Kindelia.check(context{term.name} <- term.type, world, term.body, type)
      expr && body
    call:
      //log("-- call ")  // DEBUG
      use bond = Kindelia.get_bond(world, term.bond) abort false
      let size = Nat.eql(List.length!(term.args), List.length!(bond.args))
      let otyp = Kindelia.equal(bond.otyp, type)

      let args = true
      let args = for arg in Kindelia.call_list(term.args, bond.args):
        args && Kindelia.check(context, world, arg@fst, arg@snd)
      size && otyp && args

      //let args = List.zip!!(term.args, [for x in bond.args: x@snd])
      //let args = List.all!((x) Kindelia.check(context, world, x@fst, x@snd), args)
      //size && otyp && args
    create: case type {
      data:
        use data = Kindelia.get_data(world, type.name) abort false
        //use ctor = Kindelia.get_constructor_value(data,term.ctor) abort false
        use ctor = data.ctrs[term.ctor] abort false
        let size = Nat.eql(List.length!(term.vals), List.length!(ctor.args))
        
        let vals = true
        let vals = for arg in Kindelia.call_list(term.vals, ctor.args):
          vals && Kindelia.check(context, world, arg@fst, arg@snd)

        //let vals = List.zip!!(term.vals, [for x in ctor.args: x@snd])
        //let vals = List.all!((x) Kindelia.check(context, world, x@fst, x@snd), vals)
        size && vals
    } default false
    match: 
      use data = Kindelia.get_data(world, term.data) abort false
      let size = Nat.eql(List.length!(term.cses), List.length!(data.ctrs))
      let expr = Kindelia.check(context, world, Kindelia.Term.var(term.name), Kindelia.Type.data(term.data))
      let cses = true
      let cses = for cse in Kindelia.case_list(term.name, data.ctrs, term.cses):
        cses && Kindelia.check(Kindelia.extend!(context, cse@fst), world, cse@snd, type)
      //let cses = List.zipped_with!!(term.cses, data.ctrs)!((case_body, case_ctor)
        //let args = [for arg in case_ctor@args: {term.name | "." | arg@fst, arg@snd}]
        //let ctx2 = Kindelia.extend!(context, args)
        //Kindelia.check(ctx2, world, case_body, type))
      size && cses
    word: case type {
      word: true
    } default false
    compare:
      //log("-- compare ")  // DEBUG
      let val0 = Kindelia.check(context, world, term.val0, Kindelia.Type.word)
      let val1 = Kindelia.check(context, world, term.val1, Kindelia.Type.word)
      let iflt = Kindelia.check(context, world, term.iflt, type)
      let ifeq = Kindelia.check(context, world, term.ifeq, type)
      let ifgt = Kindelia.check(context, world, term.ifgt, type)
      val0 && val1 && iflt && ifeq && ifgt
    operate:
      let val0 = Kindelia.check(context, world, term.val0, Kindelia.Type.word)
      let val1 = Kindelia.check(context, world, term.val1, Kindelia.Type.word)
      val0 && val1
    bind:
      use bond = Kindelia.get_bond(world, term.bond) abort false
      let notf = List.is_empty!(bond.args)
      let expr = Kindelia.check(context, world, term.expr, bond.otyp)
      let cont = Kindelia.check(context, world, term.cont, type)
      notf && expr && cont
  } default false

// Evaluation
// ----------

// opcode  | cost
// ------- | -------------------------------
// var     | 1
// subs    | 1
// alloc   | 1
// let     | subst
// call    | 1 + subst * bond_arity
// match   | 1 + subst * ctor_arity
// create  | 1 + alloc * ctor_arity
// compare | 1
// operate | 1
// bind    | 1

Kindelia.cost.subs: Nat
  1

Kindelia.cost.alloc: Nat
  1

Kindelia.cost.let: Nat
  Kindelia.cost.subs

Kindelia.cost.call(bond_arity: Nat): Nat
  1 + Kindelia.cost.subs * bond_arity

Kindelia.cost.match(ctor_arity: Nat): Nat
  1 + Kindelia.cost.subs * ctor_arity

Kindelia.cost.create(ctor_arity: Nat): Nat
  1 + Kindelia.cost.alloc * ctor_arity

Kindelia.cost.compare: Nat
  1

Kindelia.cost.operate: Nat
  1

Kindelia.cost.bind: Nat
  1

// Reduces a pure term to weak normal form
Kindelia.reduce(state: Kindelia.Runtime<Kindelia.Term>): Kindelia.Runtime<Kindelia.Term>
  let {world, subst, fresh, costs, term} = state
  //log("-- run " | Kindelia.show.term(world,Kindelia.Type.word,term)) // DEBUG
  //log("-- var " | String.join(", ", List.map!!((x) x@fst|":"|Kindelia.show.term(world,Kindelia.Type.word,x@snd), Map.to_list!(subst)))) // DEBUG
  //log("")
  case term {
    var:
      let {world, subst, fresh, costs, term} = Kindelia.reduce({world, subst, fresh, costs, subst{term.name} <> term})
      {world, subst{term.name} <- term, fresh, costs, term}
    let:
      let {world, subst ,fresh, costs, expr} = Kindelia.reduce({world, subst, fresh, costs, term.expr})
      let subst = subst{term.name} <- expr
      let costs = Kindelia.cost.let + costs
      Kindelia.reduce({world, subst, fresh, costs, term.body})
    call:
      use bond = Kindelia.get_bond(world, term.bond) abort state
      let nam0 = [for x in bond.args: x@fst]
      let {fresh, nam1} = Kindelia.fresh.many(fresh, List.length!(nam0))
      let {fresh, main} = Kindelia.sanitize(world, fresh, Kindelia.extend!({},List.zip!!(nam0,nam1)), bond.main)
      let {world, subst, fresh, costs, args} = Kindelia.reduce.many({world, subst, fresh, costs, term.args})
      let subst = Kindelia.extend!(subst, List.zip!!(nam1, args))
      let costs = Kindelia.cost.create(List.length!(term.args)) + costs
      Kindelia.reduce({world, subst, fresh, costs, main})
    create:
      let {world, subst, fresh, costs, vals} = Kindelia.reduce.many({world, subst, fresh, costs, term.vals})
      {world, subst, fresh, costs, Kindelia.Term.create(term.ctor, vals)}
    match:
      let {world, subst, fresh, costs, expr} = Kindelia.reduce({world, subst, fresh, costs, subst{term.name}<>Kindelia.Term.word(0)})
      case expr {
        create:
          use data  = Kindelia.get_data(world,term.data) abort state
          use ctor  = data.ctrs[expr.ctor] abort state
          let body  = term.cses[expr.ctor] abort state
          let nams  = List.map!!((args) term.name|"."|args@fst, ctor@args)
          let subst = Kindelia.extend!(subst, List.zip!!(nams, expr.vals))
          let costs = Kindelia.cost.match(List.length!(expr.vals)) + costs
          Kindelia.reduce({world, subst, fresh, costs, body})
      } default state
    word:
      {world, subst, fresh, costs, term}
    compare:
      let {world, subst, fresh, costs, val0} = Kindelia.reduce({world, subst, fresh, costs, term.val0})
      let {world, subst, fresh, costs, val1} = Kindelia.reduce({world, subst, fresh, costs, term.val1})
      let term = case val0 val1 {
        word word: case U64.cmp(val0.numb, val1.numb) {
          ltn: term.iflt
          eql: term.ifeq
          gtn: term.ifgt
        }
      } default term
      let costs = Kindelia.cost.compare + costs
      {world, subst, fresh, costs, term}
    operate:
      let {world, subst, fresh, costs, val0} = Kindelia.reduce({world, subst, fresh, costs, term.val0})
      let {world, subst, fresh, costs, val1} = Kindelia.reduce({world, subst, fresh, costs, term.val1})
      let term = case val0 val1 {
        word word: case term.oper {
          add: Kindelia.Term.word(U64.add(val0.numb,val1.numb))
          sub: Kindelia.Term.word(U64.sub(val0.numb,val1.numb))
          mul: Kindelia.Term.word(U64.mul(val0.numb,val1.numb))
          div: Kindelia.Term.word(U64.div(val0.numb,val1.numb))
          mod: Kindelia.Term.word(U64.mod(val0.numb,val1.numb))
          or:  Kindelia.Term.word(U64.or( val0.numb,val1.numb))
          and: Kindelia.Term.word(U64.and(val0.numb,val1.numb))
          xor: Kindelia.Term.word(U64.xor(val0.numb,val1.numb))
        }
      } default term
      let costs = Kindelia.cost.operate + costs
      {world, subst, fresh, costs, term}
    bind:
      use bond = Kindelia.get_bond(world, term.bond) abort state
      let {world, subst, fresh, costs, expr} = Kindelia.reduce({world, subst, fresh, costs, term.expr})
      let entry = Kindelia.Entry.bond(bond@main <- expr)
      let world = world@entry{term.bond} <- entry
      let costs = Kindelia.cost.bind + costs
      Kindelia.reduce({world, subst, fresh, costs, term.cont})
  }

Kindelia.reduce.many(state: Kindelia.Runtime<List<Kindelia.Term>>): Kindelia.Runtime<List<Kindelia.Term>>
  let {world, subst, fresh, costs, vals} = state
  case vals {
    nil:
      state
    cons:
      let {world, subst, fresh, costs, head} = Kindelia.reduce({world, subst, fresh, costs, vals.head})
      let {world, subst, fresh, costs, tail} = Kindelia.reduce.many({world, subst, fresh, costs, vals.tail})
      {world, subst, fresh, costs, head & tail}
  }

// Renames variables to unique names
Kindelia.sanitize(
  world: Kindelia.World
  fresh: Nat
  table: Map<String>
  term: Kindelia.Term
): Pair<Nat, Kindelia.Term>
  case term {
    var:
      let term = Kindelia.Term.var(table{term.name} <> term.name)
      {fresh, term}
    let:
      let {fresh, name} = Kindelia.fresh(fresh)
      let {fresh, expr} = Kindelia.sanitize(world, fresh, table, term.expr)
      let {fresh, body} = Kindelia.sanitize(world, fresh, table{term.name} <- name, term.body)
      {fresh, Kindelia.Term.let(name, term.type, expr, body)}
    call:
      let {fresh, args} = Kindelia.sanitize.many(world, fresh, table, term.args)
      {fresh, Kindelia.Term.call(term.bond, args)}
    create:
      let {fresh, vals} = Kindelia.sanitize.many(world, fresh, table, term.vals)
      {fresh, Kindelia.Term.create(term.ctor, vals)}
    match:
      let ctrs = Kindelia.get_ctrs(world, term.data) <> []
      let nam0 = term.name
      let nam1 = table{term.name} <> term.name
      let {fresh, cses} = Kindelia.sanitize.cases(world, fresh, table, nam0, nam1, ctrs, term.cses)
      {fresh, Kindelia.Term.match(nam1, term.data, cses)}
    word:
      {fresh, Kindelia.Term.word(term.numb)}
    compare:
      let {fresh, val0} = Kindelia.sanitize(world, fresh, table, term.val0)
      let {fresh, val1} = Kindelia.sanitize(world, fresh, table, term.val1)
      let {fresh, iflt} = Kindelia.sanitize(world, fresh, table, term.iflt)
      let {fresh, ifeq} = Kindelia.sanitize(world, fresh, table, term.ifeq)
      let {fresh, ifgt} = Kindelia.sanitize(world, fresh, table, term.ifgt)
      {fresh, Kindelia.Term.compare(val0, val1, iflt, ifeq, ifgt)}
    operate:
      let {fresh, val0} = Kindelia.sanitize(world, fresh, table, term.val0)
      let {fresh, val1} = Kindelia.sanitize(world, fresh, table, term.val1)
      {fresh, Kindelia.Term.operate(term.oper, val0, val1)}
    bind:
      use bond = Kindelia.get_bond(world, term.bond) abort {fresh, term}
      let {fresh, expr} = Kindelia.sanitize(world, fresh, table, term.expr)
      let {fresh, cont} = Kindelia.sanitize(world, fresh, table, term.cont)
      {fresh, Kindelia.Term.bind(term.bond, expr, cont)}
  }

Kindelia.sanitize.cases(
  world: Kindelia.World
  fresh: Nat
  table: Map<String>
  nam0: String
  nam1: String
  ctrs: List<Kindelia.Constructor>
  cses: List<Kindelia.Term>
): Pair<Nat, List<Kindelia.Term>>
  case ctrs cses {
    nil nil:
      {fresh, []}
    cons cons:
      let table2 = table
      let table2 = for field in ctrs.head@args:
        table2{nam0 | "." | field@fst} <- nam1 | "." | field@fst
      let {fresh, head} = Kindelia.sanitize(world, fresh, table2, cses.head)
      let {fresh, tail} = Kindelia.sanitize.cases(world, fresh, table, nam0, nam1, ctrs.tail, cses.tail)
      {fresh, head & tail}
  } default {fresh, []}

Kindelia.sanitize.many(
  world: Kindelia.World
  fresh: Nat
  table: Map<String>
  terms: List<Kindelia.Term>
): Pair<Nat, List<Kindelia.Term>>
  case terms {
    nil:
      {fresh, []}
    cons:
      let {fresh, head} = Kindelia.sanitize(world, fresh, table, terms.head)
      let {fresh, tail} = Kindelia.sanitize.many(world, fresh, table, terms.tail)
      {fresh, head & tail}
  }

Kindelia.fresh(fresh: Nat): Pair<Nat, String>
  {Nat.succ(fresh), "$" | Nat.show(fresh)}

Kindelia.fresh.many(fresh: Nat, count: Nat): Pair<Nat, List<String>>
  case count {
    zero:
      {fresh, []}
    succ:
      let {fresh, head} = Kindelia.fresh(fresh)
      let {fresh, tail} = Kindelia.fresh.many(fresh, count.pred)
      {Nat.succ(fresh), head & tail}
  }

// Transaction
// -----------

Kindelia.transact(
  world: Kindelia.World
  transaction: Kindelia.Transaction
): Maybe<Pair<Kindelia.World,String>>
  case transaction {
    new_data:
      use data = transaction.data
      case world@entry{data.name} as got_type {
        none:
          let world = world@entry{data.name} <- Kindelia.Entry.data(data)
          some({world, "[data] " | data.name})
      } default none
    new_bond:
      use bond = transaction.bond
      case world@entry{bond.name} as got {
        none:
          let world = world@entry{bond.name} <- Kindelia.Entry.bond(bond)
          let context = Kindelia.extend<Kindelia.Type>({}, bond.args)
          if Kindelia.check(context, world, bond.main, bond.otyp) then
            some({world, "[bond] " | bond.name})
          else
            none
      } default
        none
    new_eval:
      use eval = transaction.eval
      // Checks authentication
      let auth = case eval.auth {
        none: true
        some:
          let call = Kindelia.Term.call(eval.auth.value@bond, eval.auth.value@args)
          if Kindelia.check({}, world, call, Kindelia.Type.word) then
            // TODO: add this to the total costs cost
            let {world, subst, fresh, costs, norm} = Kindelia.reduce({world, {}, 0, 0, call})
            case norm {
              word: U64.eql(norm.numb, 1#64)
            } default false
          else
            false
      }
      // Executes block
      if auth && Kindelia.check({}, world, eval.term, eval.type) then
        let {fresh, term} = Kindelia.sanitize(world, 0, {}, eval.term)
        let {world, subst, fresh, costs, term} = Kindelia.reduce({world, {}, fresh, 0, term})
        some({world, "[eval] " | "<$" | Nat.show(costs) | "> " | Kindelia.show.term(world, eval.type, term)})
      else
        none
    new_name:
      let name = transaction.name
      case world@names@numb{name} as got {
        some:
          none
        none:
          let indx = Nat.show(world@names@size)
          let world@names@numb{name} <- world@names@size
          let world@names@name{indx} <- name
          let world@names@size <- world@names@size + 1
          some({world, "[name] " | name})
      }
  }

// Serialization
// -------------

Kindelia.serialize.varlen(value: Nat): Bits
  Kindelia.serialize.varlen.go(Nat.add(value,1))

Kindelia.deserialize.varlen(bits: Bits): Pair<Bits,Nat>
  let {bits,value} = Kindelia.deserialize.varlen.go(bits)
  {bits, Nat.sub(value,1)}

Kindelia.serialize.varlen.go(value: Nat): Bits
  case value {
    zero: Bits.e
    succ:
      if Nat.eql(value,1) then
        Bits.o(Bits.e)
      else if Nat.eql(Nat.mod(value,2),0)
        then Bits.i(Bits.o(Kindelia.serialize.varlen.go(Nat.div(value,2))))
        else Bits.i(Bits.i(Kindelia.serialize.varlen.go(Nat.div(value,2))))
  }

Kindelia.deserialize.varlen.go(bits: Bits): Pair<Bits,Nat>
  case bits {
    e: {Bits.e, 0}
    o: {bits.pred, 1}
    i: case bits.pred {
      e: {bits.pred, 0}
      o:
        let {bits,x} = Kindelia.deserialize.varlen.go(bits.pred.pred)
        {bits, Nat.mul(x,2)}
      i:
        let {bits,x} = Kindelia.deserialize.varlen.go(bits.pred.pred)
        {bits, Nat.add(Nat.mul(x,2),1)}
    }
  }

Kindelia.serialize.fixlen(size: Nat, value: Nat): Bits
  case size {
    zero: Bits.e
    succ: if Nat.eql(Nat.mod(value,2),0)
      then Bits.o(Kindelia.serialize.fixlen(size.pred, Nat.div(value,2)))
      else Bits.i(Kindelia.serialize.fixlen(size.pred, Nat.div(value,2)))
  }

Kindelia.deserialize.fixlen(size: Nat, bits: Bits): Pair<Bits,Nat>
  case size {
    zero: {bits, 0}
    succ: case bits {
      e: {Bits.e, 0}
      o:
        let {bits,x} = Kindelia.deserialize.fixlen(size.pred, bits.pred)
        {bits, Nat.mul(x,2)}
      i:
        let {bits,x} = Kindelia.deserialize.fixlen(size.pred, bits.pred)
        {bits, Nat.add(Nat.mul(x,2),1)}
    }
  }

Kindelia.serialize.pair<A: Type, B: Type>(first: A -> Bits, second: B -> Bits, pair: Pair<A, B>): Bits
  open pair
  let fst = first(pair.fst)
  let snd = second(pair.snd)
  Bits.concat(fst, snd)

Kindelia.deserialize.pair<A: Type, B: Type>(first: Bits -> Pair<Bits, A>, second: Bits -> Pair<Bits, B>, bits: Bits): Pair<Bits, Pair<A,B>>
  let {bits, fst} = first(bits)
  let {bits, snd} = second(bits)
  {bits, {fst, snd}}

Kindelia.serialize.maybe<A: Type>(item: A -> Bits, maybe: Maybe<A>): Bits
  case maybe {
    none: Bits.o(Bits.e)
    some: Bits.i(item(maybe.value))
  }

Kindelia.deserialize.maybe<A: Type>(item: Bits -> Pair<Bits,A>, bits: Bits): Pair<Bits, Maybe<A>>
  case bits {
    o: {bits.pred, none}
    i: let {bits, value} = item(bits.pred); {bits, some(value)}
    e: {Bits.e, none}
  }

Kindelia.serialize.list<A: Type>(item: A -> Bits, list: List<A>): Bits
  case list {
    nil: Bits.o(Bits.e)
    cons: Bits.i(Bits.concat(item(list.head), Kindelia.serialize.list<A>(item, list.tail)))
  }

Kindelia.deserialize.list<A: Type>(item: Bits -> Pair<Bits,A>, bits: Bits): Pair<Bits,List<A>>
  case bits {
    e: {Bits.e, []}
    o: {bits.pred, []}
    i:
      let {bits, head} = item(bits.pred)
      let {bits, tail} = Kindelia.deserialize.list<A>(item, bits)
      {bits, head & tail}
  }

Kindelia.serialize.letters(name: String): Bits
  case name {
    nil:
      Bits.o(Bits.e)
    cons:
      let numb =
        if U16.btw('0', name.head, '9') then
          U16.sub(name.head, '0')
        else if U16.btw('A', name.head, 'Z') then
          U16.add(U16.sub(name.head, 'A'), 10#16)
        else if U16.btw('a', name.head, 'z') then
          U16.add(U16.sub(name.head, 'a'), 36#16)
        else if U16.btw('_', name.head, '_') then
          62#16
        else
          63#16
      let head = Kindelia.serialize.fixlen(6, U16.to_nat(numb))
      let tail = Kindelia.serialize.letters(name.tail)
      Bits.i(Bits.concat(head, tail))
  }

Kindelia.deserialize.letters(bits: Bits): Pair<Bits,String>
  case bits {
    e: {Bits.e, ""}
    o: {bits.pred, ""}
    i:
      let {bits, numb} = Kindelia.deserialize.fixlen(6, bits.pred)
      let {bits, tail} = Kindelia.deserialize.letters(bits)
      let numb = Nat.to_u16(numb)
      let head =
        if U16.btw(0, numb, 9) then
          U16.add(numb, '0')
        else if U16.btw(10, numb, 35) then
          U16.add(U16.sub(numb,10#16), 'A')
        else if U16.btw(36, numb, 61) then
          U16.add(U16.sub(numb,36#16), 'a')
        else if U16.btw(62, numb, 62) then
          '_'
        else
          '.'
      {bits, String.cons(head,tail)}
  }

Kindelia.serialize.name(world: Kindelia.World, name: String): Bits
  case world@names@numb{name} as found {
    none: Bits.o(Kindelia.serialize.letters(name))
    some: Bits.i(Kindelia.serialize.varlen(found.value))
  }

Kindelia.deserialize.name(world: Kindelia.World, bits: Bits): Pair<Bits,String>
  case bits {
    o:
      Kindelia.deserialize.letters(bits.pred)
    i:
      let {bits,index} = Kindelia.deserialize.varlen(bits.pred)
      {bits, world@names@name{Nat.show(index)} <> ""}
    e:
      {Bits.e, ""}
  }

Kindelia.serialize.name.local(world: Kindelia.World, vars: List<String>, name: String): Bits
  case List.find_index!(vars, String.eql(name)) as got {
    none: Bits.e
    some: Kindelia.serialize.varlen(got.value)
  }

Kindelia.deserialize.name.local(world: Kindelia.World, vars: List<String>, bits: Bits): Pair<Bits,String>
  let {bits,numb} = Kindelia.deserialize.varlen(bits)
  {bits, vars[numb] <> ""}

Kindelia.serialize.term(world: Kindelia.World, vars: List<String>, term: Kindelia.Term): Bits
  case term {
    var:
      Bits.o(Kindelia.serialize.name.local(world, vars, term.name))
    let:
      let name = Kindelia.serialize.name(world, term.name)
      let type = Kindelia.serialize.type(world,term.type) // TODO
      let expr = Kindelia.serialize.term(world,vars,term.expr)
      let body = Kindelia.serialize.term(world,term.name&vars,term.body)
      Bits.i(Bits.o(Bits.o(Bits.o(Bits.concat(name, Bits.concat(type, Bits.concat(expr, body)))))))
    call:
      let bond = Kindelia.serialize.name(world, term.bond)
      let args = Kindelia.serialize.list!(Kindelia.serialize.term(world,vars), term.args)
      Bits.i(Bits.i(Bits.o(Bits.o(Bits.concat(bond, args)))))
    create:
      //let ctor = Kindelia.serialize.name(world, term.ctor)
      let ctor = Kindelia.serialize.varlen(term.ctor)
      let vals = Kindelia.serialize.list!(Kindelia.serialize.term(world,vars), term.vals)
      Bits.i(Bits.o(Bits.i(Bits.o(Bits.concat(ctor, vals)))))
    match:
      let name = Kindelia.serialize.name.local(world,vars,term.name)
      let data = Kindelia.serialize.name(world, term.data)
      let cses = Kindelia.serialize.cases(world,vars,term.name,Kindelia.get_ctrs(world,term.data)<>[],term.cses)
      Bits.i(Bits.i(Bits.i(Bits.o(Bits.concat(name, Bits.concat(data, cses))))))
    word:
      let numb = Kindelia.serialize.fixlen(64, U64.to_nat(term.numb))
      Bits.i(Bits.o(Bits.o(Bits.i(numb))))
    compare:
      let val0 = Kindelia.serialize.term(world,vars,term.val0)
      let val1 = Kindelia.serialize.term(world,vars,term.val1)
      let iflt = Kindelia.serialize.term(world,vars,term.iflt)
      let ifeq = Kindelia.serialize.term(world,vars,term.ifeq)
      let ifgt = Kindelia.serialize.term(world,vars,term.ifgt)
      Bits.i(Bits.i(Bits.o(Bits.i(Bits.concat(val0, Bits.concat(val1, Bits.concat(iflt, Bits.concat(ifeq, ifgt))))))))
    operate:
      let oper = Kindelia.serialize.fixlen(3, case term.oper { add:0, sub:1, mul:2, div:3, mod:4, or:5, and:6, xor:7 })
      let val0 = Kindelia.serialize.term(world,vars,term.val0)
      let val1 = Kindelia.serialize.term(world,vars,term.val1)
      Bits.i(Bits.o(Bits.i(Bits.i(Bits.concat(oper, Bits.concat(val0, val1))))))
    bind:
      let bond = Kindelia.serialize.name(world, term.bond)
      let expr = Kindelia.serialize.term(world,vars,term.expr)
      let cont = Kindelia.serialize.term(world,vars,term.cont)
      Bits.i(Bits.i(Bits.i(Bits.i(Bits.concat(bond, Bits.concat(expr, cont))))))
  } default _

Kindelia.deserialize.term(world: Kindelia.World, vars: List<String>, bits: Bits): Pair<Bits,Kindelia.Term>
  case bits {
    o:
      let {bits,name} = Kindelia.deserialize.name.local(world, vars, bits.pred)
      {bits, Kindelia.Term.var(name)}
    i:
      let {bits,ctor} = Kindelia.deserialize.fixlen(3, bits.pred)
      switch Nat.eql(ctor) {
        0:
          let {bits,name} = Kindelia.deserialize.name(world, bits)
          let {bits,type} = Kindelia.deserialize.type(world,bits)
          let {bits,expr} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,body} = Kindelia.deserialize.term(world,name&vars,bits)
          {bits, Kindelia.Term.let(name,type,expr,body)}
        1:
          let {bits,bond} = Kindelia.deserialize.name(world, bits)
          let {bits,args} = Kindelia.deserialize.list!(Kindelia.deserialize.term(world,vars), bits)
          {bits, Kindelia.Term.call(bond,args)}
        2:
          let {bits,ctor} = Kindelia.deserialize.varlen(bits)
          let {bits,vals} = Kindelia.deserialize.list!(Kindelia.deserialize.term(world,vars), bits)
          {bits, Kindelia.Term.create(ctor, vals)}
        3:
          let {bits,name} = Kindelia.deserialize.name.local(world,vars,bits)
          let {bits,data} = Kindelia.deserialize.name(world, bits)
          let {bits,cses} = Kindelia.deserialize.cases(world,vars,name,Kindelia.get_ctrs(world,data)<>[],bits)
          {bits, Kindelia.Term.match(name,data,cses)}
        4:
          let {bits,numb} = Kindelia.deserialize.fixlen(64,bits)
          {bits, Kindelia.Term.word(Nat.to_u64(numb))}
        5:
          let {bits,val0} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,val1} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,iflt} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,ifeq} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,ifgt} = Kindelia.deserialize.term(world,vars,bits)
          {bits, Kindelia.Term.compare(val0,val1,iflt,ifeq,ifgt)}
        6:
          let {bits,oper} = Kindelia.deserialize.fixlen(3, bits)
          let {bits,val0} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,val1} = Kindelia.deserialize.term(world,vars,bits)
          let oper = switch Nat.eql(oper) {
            0: Kindelia.Operation.add
            1: Kindelia.Operation.sub
            2: Kindelia.Operation.mul
            3: Kindelia.Operation.div
            4: Kindelia.Operation.mod
            5: Kindelia.Operation.or
            6: Kindelia.Operation.and
            7: Kindelia.Operation.xor
          } default Kindelia.Operation.add
          {bits, Kindelia.Term.operate(oper, val0, val1)}
        7:
          let {bits,bond} = Kindelia.deserialize.name(world, bits)
          let {bits,expr} = Kindelia.deserialize.term(world,vars,bits)
          let {bits,cont} = Kindelia.deserialize.term(world,vars,bits)
          {bits, Kindelia.Term.bind(bond,expr,cont)}
      } default {bits, Kindelia.Term.word(0)}
  } default {bits, Kindelia.Term.word(0)}

Kindelia.serialize.cases(
  world: Kindelia.World
  vars: List<String>
  name: String
  ctors: List<Kindelia.Constructor>
  cases: List<Kindelia.Term>
): Bits
  case ctors cases {
    nil nil:
      Bits.e
    cons cons:
      let flds = List.map!!((args) name|"."|args@fst, ctors.head@args)
      let head = Kindelia.serialize.term(world, List.reverse!(flds) ++ vars, cases.head)
      let tail = Kindelia.serialize.cases(world, vars, name, ctors.tail, cases.tail)
      Bits.concat(head, tail)
  } default Bits.e

Kindelia.deserialize.cases(
  world: Kindelia.World
  vars: List<String>
  name: String
  ctors: List<Kindelia.Constructor>
  bits: Bits
): Pair<Bits, List<Kindelia.Term>>
  case ctors {
    nil:
      {bits, []}
    cons:
      let flds = List.map!!((args) name|"."|args@fst, ctors.head@args)
      let {bits,head} = Kindelia.deserialize.term(world, List.reverse!(flds) ++ vars, bits)
      let {bits,tail} = Kindelia.deserialize.cases(world, vars, name, ctors.tail, bits)
      {bits, head & tail}
  }

Kindelia.serialize.type(world: Kindelia.World, typ: Kindelia.Type): Bits
  case typ {
    word: Bits.o(Bits.e)
    data: Bits.i(Kindelia.serialize.name(world, typ.name))
  }

Kindelia.deserialize.type(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Type>
  let {bits,ctor} = Kindelia.deserialize.fixlen(1, bits)
  switch Nat.eql(ctor) {
    0:
      {bits, Kindelia.Type.word}
    1:
      let {bits,name} = Kindelia.deserialize.name(world, bits)
      {bits, Kindelia.Type.data(name)}
  } default {bits, Kindelia.Type.word}

Kindelia.serialize.data(world: Kindelia.World, data: Kindelia.Data): Bits
  open data
  let name = Kindelia.serialize.name(world, data.name)
  let ctrs = Kindelia.serialize.list!(Kindelia.serialize.constructor(world), data.ctrs)
  Bits.concat(name, ctrs)

Kindelia.deserialize.data(world: Kindelia.World, bits: Bits): Pair<Bits, Kindelia.Data>
  let {bits,name} = Kindelia.deserialize.name(world, bits)
  let {bits,ctrs} = Kindelia.deserialize.list!(Kindelia.deserialize.constructor(world), bits)
  {bits, Kindelia.Data.new(name,ctrs)}

Kindelia.serialize.constructor(world: Kindelia.World, ctor: Kindelia.Constructor): Bits
  open ctor
  let name = Kindelia.serialize.name(world, ctor.name)
  let args = Kindelia.serialize.list!(
    Kindelia.serialize.pair!!(Kindelia.serialize.name(world), Kindelia.serialize.type(world)),
    ctor.args
  )
  Bits.concat(name, args)
  
Kindelia.deserialize.constructor(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Constructor>
  let {bits,name} = Kindelia.deserialize.name(world, bits)
  let {bits,args} = Kindelia.deserialize.list!(
    Kindelia.deserialize.pair!!(Kindelia.deserialize.name(world), Kindelia.deserialize.type(world)),
    bits
  )
  {bits, Kindelia.Constructor.new(name, args)}

Kindelia.serialize.bond(world: Kindelia.World, bond: Kindelia.Bond): Bits
  open bond
  let name = Kindelia.serialize.name(world, bond.name)
  let ownr = Kindelia.serialize.list!(Kindelia.serialize.name(world), bond.ownr)
  let args = Kindelia.serialize.list!(Kindelia.serialize.pair!!(Kindelia.serialize.name(world), Kindelia.serialize.type(world)), bond.args)
  let otyp = Kindelia.serialize.type(world, bond.otyp)
  let inam = List.reverse!(List.mapped!(bond.args)!(Pair.fst!!))
  let main = Kindelia.serialize.term(world, inam, bond.main)
  Bits.concat(name, Bits.concat(ownr, Bits.concat(args, Bits.concat(otyp, main))))

Kindelia.deserialize.bond(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Bond>
  let {bits,name} = Kindelia.deserialize.name(world, bits)
  let {bits,ownr} = Kindelia.deserialize.list!(Kindelia.deserialize.name(world), bits)
  let {bits,args} = Kindelia.deserialize.list!(Kindelia.deserialize.pair!!(Kindelia.deserialize.name(world), Kindelia.deserialize.type(world)), bits)
  let {bits,otyp} = Kindelia.deserialize.type(world, bits)
  let inam = List.reverse!(List.mapped!(args)!(Pair.fst!!))
  let {bits,main} = Kindelia.deserialize.term(world, inam, bits)
  {bits, Kindelia.Bond.new(name, ownr, args, otyp, main)}

Kindelia.serialize.transaction(world: Kindelia.World, transaction: Kindelia.Transaction): Bits
  case transaction {
    new_data:
      let data = Kindelia.serialize.data(world, transaction.data)
      Bits.o(Bits.o(data))
    new_bond:
      let bond = Kindelia.serialize.bond(world, transaction.bond)
      Bits.i(Bits.o(bond))
    new_eval:
      let term = Kindelia.serialize.eval(world, transaction.eval)
      Bits.o(Bits.i(term))
    new_name:
      let name = Kindelia.serialize.name(world, transaction.name)
      Bits.i(Bits.i(name))
  }

Kindelia.deserialize.transaction(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Transaction>
  let {bits,ctor} = Kindelia.deserialize.fixlen(2, bits)
  switch Nat.eql(ctor) {
    0:
      let {bits,data} = Kindelia.deserialize.data(world, bits)
      {bits, Kindelia.Transaction.new_data(data)}
    1:
      let {bits,bond} = Kindelia.deserialize.bond(world, bits)
      {bits, Kindelia.Transaction.new_bond(bond)}
    2:
      let {bits,eval} = Kindelia.deserialize.eval(world, bits)
      {bits, Kindelia.Transaction.new_eval(eval)}
    3:
      let {bits,name} = Kindelia.deserialize.name(world, bits)
      {bits, Kindelia.Transaction.new_name(name)}
  } default {bits, Kindelia.Transaction.new_data(Kindelia.Data.new("",[]))}

Kindelia.serialize.eval(world: Kindelia.World, eval: Kindelia.Eval): Bits
  open eval
  let auth = Kindelia.serialize.maybe!(Kindelia.serialize.auth(world), eval.auth)
  let term = Kindelia.serialize.term(world, [], eval.term)
  let type = Kindelia.serialize.type(world, eval.type)
  Bits.concat(auth, Bits.concat(term, type))

Kindelia.deserialize.eval(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Eval>
  let {bits,auth} = Kindelia.deserialize.maybe!(Kindelia.deserialize.auth(world), bits)
  let {bits,term} = Kindelia.deserialize.term(world, [], bits)
  let {bits,type} = Kindelia.deserialize.type(world, bits)
  {bits, Kindelia.Eval.new(auth,term,type)}

Kindelia.serialize.auth(world: Kindelia.World, auth: Kindelia.Auth): Bits
  open auth
  let bond = Kindelia.serialize.name(world, auth.bond)
  let args = Kindelia.serialize.list!(Kindelia.serialize.term(world, []), auth.args)
  Bits.concat(bond, args)
  
Kindelia.deserialize.auth(world: Kindelia.World, bits: Bits): Pair<Bits,Kindelia.Auth>
  let {bits,bond} = Kindelia.deserialize.name(world, bits)
  let {bits,args} = Kindelia.deserialize.list!(Kindelia.deserialize.term(world, []), bits)
  {bits, Kindelia.Auth.new(bond, args)}

Kindelia.serialize.block(world: Kindelia.World, block: List<Kindelia.Transaction>): Bits
  case block {
    nil:
      Bits.e
    cons:
      let head = Kindelia.serialize.transaction(world, block.head)
      let tail = Kindelia.serialize.block(world, block.tail)
      Bits.concat(head, tail)
  }

Kindelia.deserialize.block(world: Kindelia.World, bits: Bits): Pair<Bits, List<Kindelia.Transaction>>
  if Bits.is_empty(bits) then
    {Bits.e, []}
  else
    let {bits,head} = Kindelia.deserialize.transaction(world, bits)
    let {bits,tail} = Kindelia.deserialize.block(world, bits)
    {bits, head & tail}

// Stringification
// ---------------

Kindelia.show.term(
  world: Kindelia.World
  type: Kindelia.Type
  term: Kindelia.Term
): String
  case term {
    var:
      term.name
    let:
      let name = term.name
      let etyp = Kindelia.show.type(world, term.type)
      let expr = Kindelia.show.term(world, term.type, term.expr)
      let body = Kindelia.show.term(world, type, term.body)
      "let " | name | " : " | etyp | " = " | expr | " " | body
    create:
      case type {
        data:
          use data = Kindelia.get_data(world, type.name) abort "[create?]"
          use ctor = data.ctrs[term.ctor] abort "[create?]"
          let atyp = List.mapped!(ctor.args)!((x) x@snd)
          let vals = List.zipped_with!!(term.vals, ctor@args)!((val,arg) Kindelia.show.term(world, arg@snd, val))
          data.name | "@" | ctor.name | "{" | String.join(",",vals) | "}"
      } default Nat.show(term.ctor) | "{" | String.join(",",List.mapped!(term.vals)!(Kindelia.show.term(world,Kindelia.Type.word))) | "}"
    match:
      use data = Kindelia.get_data(world, term.data) abort "?"
      let name = term.name
      let cses = List.zipped_with!!(data.ctrs, term.cses)!((case_ctor, case_body)
        case_ctor@name | ": " | Kindelia.show.term(world, type, case_body))
      "case " | name | " : " | term.data | " { " | String.join(", ", cses) | " }"
    word:
      "#" | U64.show(term.numb)
    compare:
      let val0 = Kindelia.show.term(world, Kindelia.Type.word, term.val0)
      let val1 = Kindelia.show.term(world, Kindelia.Type.word, term.val1)
      let iflt = Kindelia.show.term(world, type, term.iflt)
      let ifeq = Kindelia.show.term(world, type, term.ifeq)
      let ifgt = Kindelia.show.term(world, type, term.ifgt)
      "compare " | val0 | " " | val1 | " { _<_: " | iflt | " _=_: " | ifeq | " _>_: " | ifgt | " }"
    operate:
      let oper = case term.oper { add: "#add", sub: "#sub", mul: "#mul", div: "#div", mod: "#mod", or: "#or", and: "#and", xor: "#xor" }
      let val0 = Kindelia.show.term(world, Kindelia.Type.word, term.val0)
      let val1 = Kindelia.show.term(world, Kindelia.Type.word, term.val1)
      oper | "(" | val0 | "," | val1 | ")"
    call:
      use bond = Kindelia.get_bond(world, term.bond) abort "[call?]"
      let args = List.zipped_with!!(bond.args, term.args)!((inp,arg) Kindelia.show.term(world, inp@snd, arg))
      term.bond | "(" | String.join(",", args) | ")"
    bind:
      use bond = Kindelia.get_bond(world, term.bond) abort "[bind?]"
      let expr = Kindelia.show.term(world, bond.otyp, term.expr)
      let cont = Kindelia.show.term(world, type, term.cont)
      "bind " | term.bond | " { " | expr | " } " | cont
  }

Kindelia.show.type(
  world: Kindelia.World
  type: Kindelia.Type
): String
  case type {
    word: "#word"
    data: type.name
  }

Kindelia.show.data(
  world: Kindelia.World
  data: Kindelia.Data
): String
  open data
  "data " | data.name | " { "
  | String.join(", ", List.mapped!(data.ctrs)!((Kindelia.show.constructor(world))))
  | " }"

Kindelia.show.constructor(
  world: Kindelia.World
  constructor: Kindelia.Constructor
): String
  open constructor
  let fields = [for args in constructor.args: args@fst | ": " | Kindelia.show.type(world, args@snd)]
  constructor.name | "{" | String.join(", ", fields) | "}"
    
Kindelia.show.bond(
  world: Kindelia.World
  bond: Kindelia.Bond
): String
  open bond
  "bond "
  | bond.name
  | "("
  | String.join(",", List.mapped!(bond.args)!((x) x@fst | ": " | Kindelia.show.type(world, x@snd)))
  | "): "
  | Kindelia.show.type(world,bond.otyp)
  | " { "
  | Kindelia.show.term(world,bond.otyp,bond.main)
  | " }"

Kindelia.show.entry(
  world: Kindelia.World
  entry: Kindelia.Entry
): String
  case entry {
    data: Kindelia.show.data(world, entry.value)
    bond: Kindelia.show.bond(world, entry.value)
  } | "\n"

Kindelia.show.eval(
  world: Kindelia.World
  eval: Kindelia.Eval
): String
  open eval
  let auth = case eval.auth {
    none: ""
    some: " " | Kindelia.show.term(world, Kindelia.Type.word, Kindelia.Term.call(eval.auth.value@bond, eval.auth.value@args))
  }
  let term = Kindelia.show.term(world, eval.type, eval.term)
  let type = Kindelia.show.type(world, eval.type)
  "eval" | auth | " {" | term | "} : " | type | auth

Kindelia.show.transaction(
  world: Kindelia.World
  transaction: Kindelia.Transaction
): String
  case transaction {
    new_data: Kindelia.show.data(world, transaction.data)
    new_bond: Kindelia.show.bond(world, transaction.bond)
    new_eval: Kindelia.show.eval(world, transaction.eval)
    new_name: "name " | transaction.name
  }

Kindelia.show.block(
  world: Kindelia.World
  block: List<Kindelia.Transaction>
): String
  case block {
    nil:
      ""
    cons:
      let head = Kindelia.show.transaction(world, block.head)
      let tail = Kindelia.show.block(world, block.tail)
      "- " | head | "\n" | tail
  }

// Parsing
// -------

Kindelia.parse.ignore: Parser(List<Unit>)
 Parser.many!(Parser.choice!([
   Parser.text(" ")
   Parser.text("\t")
   Parser.text("\r")
   Parser.text("\n")
   Parser {
     Parser.text("//")
     let end = Parser.choice!([Parser.text("\n"), Parser.eof])
     Parser.until!(end, Parser.one)
     return unit
   }
 ]))

Kindelia.parse.text(text: String): Parser(Unit)
  Parser {
    Kindelia.parse.ignore
    Parser.text(text)
  }

Kindelia.parse.name: Parser<String>
 Parser {
   Kindelia.parse.ignore
   get fst_chr = Kindelia.parse.letter
   get chrs = Parser.many<Kind.Letter>(Kindelia.parse.letter)
   return String.cons(fst_chr, List.fold!(chrs)!(String.nil, String.cons))
 }

Kindelia.parse.letter: Parser<Char>
  Parser.letter((chr)
    if      U16.btw('A', chr, 'Z') then Bool.true
    else if U16.btw('a', chr, 'z') then Bool.true
    else if U16.btw('0', chr, '9') then Bool.true
    else if U16.eql('.', chr)      then Bool.true
    else if U16.eql('_', chr)      then Bool.true
    else if U16.eql('^', chr)      then Bool.true
    else                                Bool.false)

Kindelia.parse.term(world: Kindelia.World): Parser<Kindelia.Term>
 Parser.choice!([
    Kindelia.parse.term.let(world)
    Kindelia.parse.term.create(world)
    Kindelia.parse.term.match(world)
    Kindelia.parse.term.word(world)
    Kindelia.parse.term.compare(world)
    Kindelia.parse.term.operate(world)
    Kindelia.parse.term.bind(world)
    Kindelia.parse.term.call(world)
    Kindelia.parse.term.var(world)
 ])

Kindelia.parse.term.let(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("let")
    get name = Kindelia.parse.name
    Kindelia.parse.text(":")
    get type = Kindelia.parse.type(world)
    Kindelia.parse.text("=")
    get expr = Kindelia.parse.term(world)
    Parser.maybe!(Kindelia.parse.text(";"))
    get body = Kindelia.parse.term(world)
    return Kindelia.Term.let(name, type, expr, body)
 }

Kindelia.parse.term.create(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    get data_name = Kindelia.parse.name
    Kindelia.parse.text("@")
    get ctor_name = Kindelia.parse.name
    use data = Kindelia.get_data(world, data_name) abort Parser.fail!("Type not found.")
    Kindelia.parse.text("{")
    use ctor = List.find!((ctor) String.eql(ctor@name, ctor_name), data.ctrs) abort Parser.fail!("Constructor not found.")
    get vals = Kindelia.parse.term.create.fields(world, List.mapped!(ctor.args)!(Pair.fst!!))
    Kindelia.parse.text("}")
    let cnam = List.mapped!(data@ctrs)!((x) x@name)
    let ctor = List.find_index!(cnam, String.eql(ctor_name)) <> 0
    return Kindelia.Term.create(ctor, vals)
 }

Kindelia.parse.term.create.fields(
  world: Kindelia.World
  fields: List<String>
): Parser<List<Kindelia.Term>>
  case fields {
    nil: Parser {
      return []
    }
    cons: Parser {
      Parser.maybe!(Parser {
        Kindelia.parse.text(fields.head)
        Kindelia.parse.text(":")
      })
      get head = Kindelia.parse.term(world)
      get tail = Kindelia.parse.term.create.fields(world, fields.tail)
      Parser.maybe!(Kindelia.parse.text(","))
      return head & tail
    }
  }

Kindelia.parse.term.match(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("case ")
    get name = Kindelia.parse.name
    Kindelia.parse.text(":")
    get data_name = Kindelia.parse.name
    case Kindelia.get_data(world, data_name) as found {
      none: Parser.fail!("Type not found.")
      some: Parser {
        use data = found.value
        Kindelia.parse.text("{")
        get cses = Kindelia.parse.term.match.cases(world, data.ctrs)
        Kindelia.parse.text("}")
        return Kindelia.Term.match(name, data_name, cses)
      }
    }
  }

Kindelia.parse.term.match.cases(
  world: Kindelia.World
  ctrs: List<Kindelia.Constructor>
): Parser<List<Kindelia.Term>>
 case ctrs {
   nil: Parser {
     return []
   }
   cons: Parser {
     use ctor = ctrs.head
     Kindelia.parse.text(ctor.name)
     Kindelia.parse.text(":")
     get head = Kindelia.parse.term(world)
     Parser.maybe!(Kindelia.parse.text(","))
     get tail = Kindelia.parse.term.match.cases(world, ctrs.tail)
     return head & tail
   }
 }

Kindelia.parse.term.word(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("#")
    get num = Parser.nat
    if Nat.gte(num,Nat.pow(2,64)) then
      Parser.fail!("Number out of bound")
    else Parser {
      return Kindelia.Term.word(Nat.to_u64(num))
    }
  }

Kindelia.parse.term.compare(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("compare")
    get val0 = Kindelia.parse.term(world)
    get val1 = Kindelia.parse.term(world)
    Kindelia.parse.text("{")
    Kindelia.parse.text("_<_:")
    get iflt = Kindelia.parse.term(world)
    Kindelia.parse.text("_=_:")
    get ifeq = Kindelia.parse.term(world)
    Kindelia.parse.text("_>_:")
    get ifgt = Kindelia.parse.term(world)
    Kindelia.parse.text("}")
    return Kindelia.Term.compare(val0, val1, iflt, ifeq, ifgt)
  }

Kindelia.parse.term.operate(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    get oper = Kindelia.parse.term.operation
    case oper {
      none: Parser.fail!("Not an operation.")
      some: Parser {
        Kindelia.parse.text("(")
        get val0 = Kindelia.parse.term(world)
        Parser.maybe!(Kindelia.parse.text(","))
        get val1 = Kindelia.parse.term(world)
        Kindelia.parse.text(")")
        return Kindelia.Term.operate(oper.value, val0, val1)
      }
    }
  }

Kindelia.parse.term.operation: Parser<Maybe<Kindelia.Operation>>
  Parser.choice!([
    Parser {
      Kindelia.parse.text("#add")
      return some(Kindelia.Operation.add)
    }
    Parser {
      Kindelia.parse.text("#sub")
      return some(Kindelia.Operation.sub)
    }
    Parser {
      Kindelia.parse.text("#mul")
      return some(Kindelia.Operation.mul)
    }
    Parser {
      Kindelia.parse.text("#div")
      return some(Kindelia.Operation.div)
    }
    Parser {
      Kindelia.parse.text("#mod")
      return some(Kindelia.Operation.mod)
    }
    Parser {
      Kindelia.parse.text("#or")
      return some(Kindelia.Operation.or)
    }
    Parser {
      Kindelia.parse.text("#and")
      return some(Kindelia.Operation.and)
    }
    Parser {
      Kindelia.parse.text("#xor")
      return some(Kindelia.Operation.xor)
    }
    Parser {
      return none
    }
  ])

Kindelia.parse.term.bind(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    Kindelia.parse.text("bind")
    get bond = Kindelia.parse.name
    Kindelia.parse.text("{")
    get main = Kindelia.parse.term(world)
    Kindelia.parse.text("}")
    get body = Kindelia.parse.term(world)
    return Kindelia.Term.bind(bond, main, body)
  }

Kindelia.parse.term.call(world: Kindelia.World): Parser<Kindelia.Term>
  Parser {
    get ctor = Kindelia.parse.name
    get args = Parser.wrap!(
      Kindelia.parse.text("(")
      Parser {
        get val = Kindelia.parse.term(world)
        Parser.maybe!(Kindelia.parse.text(","))
        return val
      }
      Kindelia.parse.text(")"))
    return Kindelia.Term.call(ctor, args)
 }

Kindelia.parse.term.var(
  world: Kindelia.World
): Parser<Kindelia.Term>
 Parser {
   get name = Kindelia.parse.name
   return Kindelia.Term.var(name)
 }

Kindelia.parse.type(
  world: Kindelia.World
): Parser<Kindelia.Type>
  Parser.choice!([
    Parser {
      Kindelia.parse.text("#word")
      return Kindelia.Type.word
    }
    Parser {
      get name = Kindelia.parse.name
      return Kindelia.Type.data(name)
    }
  ])

Kindelia.parse.data(world: Kindelia.World): Parser<Kindelia.Data>
  Parser {
    Kindelia.parse.text("type")
    get name = Kindelia.parse.name
    get ctors = Parser.wrap!(
      Kindelia.parse.text("{")
      Parser {
        get val = Kindelia.parse.constructor(world)
        Parser.maybe!(Kindelia.parse.text(","))
        return val
      }
      Kindelia.parse.text("}")
    )
    return Kindelia.Data.new(name, ctors)
  }
  
Kindelia.parse.constructor(world: Kindelia.World): Parser<Kindelia.Constructor>
 Parser {
   get name = Kindelia.parse.name
   get args = Parser.wrap!(
      Kindelia.parse.text("{")
      Kindelia.parse.ann(world)
      Kindelia.parse.text("}"))
   return Kindelia.Constructor.new(name, args)
 }

Kindelia.parse.bond(world: Kindelia.World): Parser<Kindelia.Bond>
  Parser {
    Kindelia.parse.text("bond")
    get name = Kindelia.parse.name
    get args = Parser.wrap!(
      Kindelia.parse.text("(")
      Kindelia.parse.ann(world)
      Kindelia.parse.text(")"))
    Kindelia.parse.text(":")
    get otyp = Kindelia.parse.type(world)
    Kindelia.parse.text("{")
    get main = Kindelia.parse.term(world)
    Kindelia.parse.text("}")
    return Kindelia.Bond.new(name, [], args, otyp, main)
  }

Kindelia.parse.ann(world: Kindelia.World): Parser<Pair<String,Kindelia.Type>>
 Parser {
    Parser.maybe!(Kindelia.parse.text(","))
    get name = Kindelia.parse.name
    Kindelia.parse.text(":")
    get type = Kindelia.parse.type(world)
    return {name, type}
 }

Kindelia.parse.eval(world: Kindelia.World): Parser<Kindelia.Eval>
  Parser {
    Kindelia.parse.text("eval")
    get auth = Parser.maybe!(Parser {
      get term = Kindelia.parse.term.call(world)
      return case term {
        call: some(Kindelia.Auth.new(term.bond, term.args))
      } default none
    })
    Kindelia.parse.text("{")
    get term = Kindelia.parse.term(world)
    Kindelia.parse.text("}")
    Kindelia.parse.text(":")
    get type = Kindelia.parse.type(world)
    let auth = case auth {
      none: none
      some: case auth.value {
        none: none
        some: some(auth.value.value)
      }
    }
    return Kindelia.Eval.new(auth, term, type)
  }

Kindelia.parse.transaction(world: Kindelia.World): Parser<Kindelia.Transaction>
  Parser.choice!([
    Parser {
      get data = Kindelia.parse.data(world)
      return Kindelia.Transaction.new_data(data)
    }
    Parser {
      get bond = Kindelia.parse.bond(world)
      return Kindelia.Transaction.new_bond(bond)
    }
    Parser {
      get term = Kindelia.parse.eval(world)
      return Kindelia.Transaction.new_eval(term)
    }
    Parser {
      Kindelia.parse.text("name ")
      get name = Kindelia.parse.name
      return Kindelia.Transaction.new_name(name)
    }
  ])

Kindelia.parse.block(world: Kindelia.World): Parser<List<Kindelia.Transaction>>
  Parser.choice!([
    Parser {
      get head = Kindelia.parse.transaction(world)
      let world = case head {
        new_bond: world@entry{head.bond@name} <- Kindelia.Entry.bond(head.bond)
        new_type: world@entry{head.type@name} <- Kindelia.Entry.type(head.type)
      } default world
      get tail = Kindelia.parse.block(world)
      return head & tail
    }
    Parser {
      Kindelia.parse.text("save")
      return []
    }
  ])

// API
// ---

Kindelia.api.run(code: String): IO<Unit>
  Kindelia.api.run.go(Kindelia.World.new(Kindelia.Names.new(0,{},{}), {}), 0, code)

Kindelia.api.run.go(
  world: Kindelia.World
  block_number: Nat
  code: String
): IO<Unit>
  let parsed = Kindelia.parse.block(world, Parser.State.new(none, "", 0, 0, code))
  case parsed {
    error: IO {
      open parsed.err
      if Nat.ltn(parsed.err.idx, String.length(code)) then IO {
        let err = parsed.err.msg | (case parsed.err.nam { nil: "", cons: " Inside " | parsed.err.nam | ":" })
        let hig = Kind.Code.highlight(code, parsed.err.ini, parsed.err.idx, Nat.succ(parsed.err.idx))
        let str = String.flatten([err, "\n", hig])
        IO.print("Error parsing block #" | Nat.show(block_number))
        IO.print(str)
      } else IO {
        IO.print("Done.")
      }
    }
    value: IO {
      let block = parsed.val
      IO.print("Block #" | Nat.show(block_number))
      let bits_0 = Kindelia.serialize.block(world, block)
      let bits_1 = Kindelia.serialize.block(world, Kindelia.deserialize.block(world, bits_0)@snd)
      IO.print("$ " | Bits.hex.encode(bits_0) | " " | if Bits.eql(bits_0,bits_1) then "ok" else "bad_serialization")
      Kindelia.api.run.go.transactions(world, block_number, parsed.pst@str, block)
    }
  }

Kindelia.api.run.go.transactions(
  world: Kindelia.World
  block_number: Nat
  code: String
  transactions: List<Kindelia.Transaction>
): IO<Unit>
  case transactions {
    nil: IO {
      IO.print("")
      Kindelia.api.run.go(world, Nat.succ(block_number), code)
    }
    cons: case Kindelia.transact(world, transactions.head) as result {
      none: IO {
        IO.print("- [fail]")
        Kindelia.api.run.go.transactions(world, block_number, code, transactions.tail)
      }
      some: IO {
        let {world, message} = result.value
        IO.print("- " | message)
        Kindelia.api.run.go.transactions(world, block_number, code, transactions.tail)
      }
    }
  }

Kindelia: _
  IO {
    let x = Kindelia.api.run
    return unit
  }
